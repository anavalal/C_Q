import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import asyncio
import logging
from datetime import datetime, time, timedelta, timezone
import json  # Necesario para formatear mensajes

# Aseg√∫rate de que esta ruta sea correcta seg√∫n tu estructura
from batch.utilities.chat_history.postgresdbservice import PostgresConversationClient

# ==================== CONFIGURACI√ìN  ====================
logging.basicConfig(level=logging.ERROR)
logger = logging.getLogger(__name__)

st.set_page_config(
    page_title="RAN AVAD Analytics Dashboard",
    page_icon="üí¨",
    layout="wide",
    initial_sidebar_state="expanded"
)

plt.rcParams.update({'font.size': 11, 'figure.facecolor': 'white', 'axes.facecolor': '#fafafa', 'grid.alpha': 0.3})

COLORES = {
    'primario': '#1f77b4', 'exito': '#2ca02c', 'peligro': '#d62728',
    'advertencia': '#ff7f0e', 'info': '#17becf', 'secundario': '#7f7f7f'
}

# ==================== FUNCIONES CORE ====================
@st.cache_data(ttl=600, show_spinner=False)
def normalizar_fechas(serie_dt):
    if serie_dt.empty:
        return serie_dt
    return pd.to_datetime(serie_dt, errors='coerce', utc=True)

def ejecutar_async(corrutina):
    try:
        return asyncio.get_event_loop().run_until_complete(corrutina)
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return loop.run_until_complete(corrutina)

# ==================== ESTILOS ====================
def aplicar_estilos():
    st.markdown("""
    <style>
    .encabezado-principal {background:linear-gradient(90deg,#667eea,#764ba2);padding:2rem;border-radius:10px;color:white;text-align:center;margin-bottom:1.5rem;box-shadow:0 4px 12px rgba(0,0,0,0.15);animation:fadeIn 0.5s ease-in;}
    @keyframes fadeIn {from{opacity:0;transform:translateY(-20px);}to{opacity:1;transform:translateY(0);}}
    .tarjeta-metrica {background:white;padding:1.2rem;border-radius:8px;border-left:4px solid #1f77b4;margin:0.5rem 0;box-shadow:0 3px 10px rgba(0,0,0,0.1);transition:all 0.3s ease;}
    .tarjeta-metrica:hover {transform:translateY(-3px);box-shadow:0 6px 20px rgba(0,0,0,0.15);}
    .numero-metrica {font-size:2rem;font-weight:bold;margin:0;color:#333;animation:countUp 0.8s ease-out;}
    @keyframes countUp {from{opacity:0;transform:scale(0.5);}to{opacity:1;transform:scale(1);}}
    .etiqueta-metrica {color:#666;font-size:0.9rem;margin:0.3rem 0 0 0;}
    .caja-filtros {background:linear-gradient(145deg,#f8f9fa,#e9ecef);padding:1.5rem;border-radius:8px;margin:1rem 0;border:1px solid #e9ecef;transition:all 0.3s ease;}
    .caja-filtros:hover {transform:translateY(-1px);box-shadow:0 4px 15px rgba(0,0,0,0.1);}
    .alerta-exito {background:linear-gradient(135deg,#d4edda,#c3e6cb);border:1px solid #c3e6cb;color:#155724;padding:1rem;border-radius:6px;margin:1rem 0;animation:slideIn 0.5s ease-out;}
    .alerta-info {background:linear-gradient(135deg,#d1ecf1,#bee5eb);border:1px solid #bee5eb;color:#0c5460;padding:1rem;border-radius:6px;margin:1rem 0;animation:slideIn 0.5s ease-out;}
    .alerta-advertencia {background:linear-gradient(135deg,#fff3cd,#ffeaa7);border:1px solid #ffeaa7;color:#856404;padding:1rem;border-radius:6px;margin:1rem 0;animation:slideIn 0.5s ease-out;}
    @keyframes slideIn {from{opacity:0;transform:translateX(-20px);}to{opacity:1;transform:translateX(0);}}

    .contenedor-conversacion {background:white;border-radius:10px;padding:1.5rem;margin:1rem 0;border-left:5px solid #d62728;box-shadow:0 4px 12px rgba(0,0,0,0.1);transition:all 0.3s ease;animation:fadeInUp 0.5s ease-out;}
    .contenedor-conversacion:hover {transform:translateY(-3px);box-shadow:0 8px 25px rgba(0,0,0,0.15);}
    @keyframes fadeInUp {from{opacity:0;transform:translateY(20px);}to{opacity:1;transform:translateY(0);}}
    .encabezado-conversacion {display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;padding-bottom:1rem;border-bottom:2px solid #f8f9fa;}
    .info-conversacion {flex:1;}
    .etiqueta-conversacion {background:#d62728;color:white;padding:0.5rem 1rem;border-radius:20px;font-weight:bold;font-size:0.9rem;animation:pulse 2s infinite;}
    @keyframes pulse {0%,100%{transform:scale(1);}50%{transform:scale(1.05);}}
    .titulo-conversacion {font-size:1.3rem;font-weight:bold;color:#2c3e50;margin:0 0 0.5rem 0;}
    .meta-conversacion {color:#6c757d;font-size:0.9rem;margin:0.2rem 0;}

    .item-mensaje {background:#f8f9fa;border-radius:8px;padding:1rem;margin:0.8rem 0;border-left:4px solid #6c757d;transition:all 0.3s ease;}
    .item-mensaje:hover {background:#e9ecef;transform:translateX(8px);box-shadow:0 3px 12px rgba(0,0,0,0.1);}
    .mensaje-usuario {border-left-color:#2ca02c !important;background:linear-gradient(135deg,#f0fff4,#e6ffed) !important;}
    .mensaje-asistente {border-left-color:#1f77b4 !important;background:linear-gradient(135deg,#f0f8ff,#e6f3ff) !important;}
    .mensaje-sistema {border-left-color:#ff7f0e !important;background:linear-gradient(135deg,#fff8f0,#ffe6d6) !important;}
    .encabezado-mensaje {display:flex;justify-content:space-between;align-items:center;margin-bottom:0.8rem;font-weight:bold;font-size:0.95rem;}
    .rol-mensaje {display:flex;align-items:center;gap:0.5rem;}
    .tiempo-mensaje {color:#6c757d;font-size:0.8rem;font-weight:normal;}
    .contenido-mensaje {background:rgba(255,255,255,0.8);padding:1rem;border-radius:6px;line-height:1.5;font-size:0.95rem;color:#2c3e50;border:1px solid rgba(0,0,0,0.1);transition:all 0.2s ease;}
    .contenido-mensaje:hover {background:rgba(255,255,255,0.95);}

    .info-tecnica-mensaje {margin-top:1rem;padding:0.8rem;background:rgba(0,0,0,0.03);border-radius:6px;border:1px dashed #dee2e6;transition:all 0.2s ease;}
    .info-tecnica-mensaje:hover {background:rgba(0,0,0,0.05);}
    .campo-tecnico {margin:0.5rem 0;padding:0.3rem 0;border-bottom:1px solid #e9ecef;font-size:0.85rem;transition:all 0.2s ease;}
    .campo-tecnico:hover {background:rgba(0,0,0,0.02);}
    .campo-tecnico:last-child {border-bottom:none;}
    .etiqueta-campo {font-weight:bold;color:#495057;margin-right:0.5rem;}
    .valor-campo {color:#6c757d;font-family:'Courier New',monospace;background:white;padding:0.2rem 0.4rem;border-radius:3px;border:1px solid #e9ecef;}

    .resumen-conversacion {background:linear-gradient(135deg,#e3f2fd,#bbdefb);padding:1rem;border-radius:8px;margin-bottom:1rem;border:1px solid #2196f3;animation:slideIn 0.5s ease-out;}
    .cuadricula-resumen {display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;margin-top:0.5rem;}
    .item-resumen {background:white;padding:0.5rem;border-radius:4px;text-align:center;font-size:0.9rem;transition:all 0.2s ease;}
    .item-resumen:hover {transform:scale(1.02);box-shadow:0 2px 8px rgba(0,0,0,0.1);}

    .contenedor-metricas {background:linear-gradient(135deg,#f8f9fa,#e9ecef);padding:2rem;border-radius:12px;margin:2rem 0;border:2px solid #dee2e6;animation:fadeIn 0.8s ease-out;}
    .titulo-seccion {font-size:1.5rem;font-weight:bold;color:#2c3e50;margin-bottom:1.5rem;text-align:center;animation:slideDown 0.6s ease-out;}
    @keyframes slideDown {from{opacity:0;transform:translateY(-10px);}to{opacity:1;transform:translateY(0);}}
    .grafico-contenedor {background:white;padding:1.5rem;border-radius:8px;margin:1rem 0;box-shadow:0 3px 10px rgba(0,0,0,0.1);transition:all 0.3s ease;}
    .grafico-contenedor:hover {transform:translateY(-2px);box-shadow:0 6px 20px rgba(0,0,0,0.15);}
    .pastilla-estadistica {background:linear-gradient(45deg,#e3f2fd,#bbdefb);padding:0.4rem 0.8rem;border-radius:15px;margin:0.3rem;display:inline-block;font-size:0.85rem;transition:all 0.2s ease;}
    .pastilla-estadistica:hover {transform:scale(1.05);box-shadow:0 2px 8px rgba(0,0,0,0.1);}
    </style>
    """, unsafe_allow_html=True)

def crear_metrica(titulo, valor, icono="üìä", color=COLORES['primario']):
    return f"""
    <div class="tarjeta-metrica" style="border-left-color:{color};">
        <div style="display:flex;justify-content:space-between;align-items:center;">
            <div>
                <div class="numero-metrica" style="color:{color};">{valor}</div>
                <div class="etiqueta-metrica">{titulo}</div>
            </div>
            <div style="font-size:1.8rem;opacity:0.7;transition:all 0.3s ease;">{icono}</div>
        </div>
    </div>
    """

# ==================== INICIALIZACI√ìN ====================
if 'bd_conectada' not in st.session_state:
    st.session_state.bd_conectada = False
if 'datos' not in st.session_state:
    st.session_state.datos = None
if 'resultados' not in st.session_state:
    st.session_state.resultados = None

# ==================== CONFIGURACI√ìN BD ====================
def mostrar_conexion():
    with st.sidebar:
        st.markdown("### üîó Conexi√≥n a Base de Datos")
        usuario = st.text_input("Usuario", "usravad")
        contrase√±a = st.text_input("Contrase√±a", "P@w0Rd1.2@25", type="password")
        servidor = st.text_input("Servidor", "teepq02s-euwepc-teradpgsql.postgres.database.azure.com")
        base_datos = st.text_input("Base de Datos", "avad_pre")
        conectar = st.button("üöÄ Conectar", type="primary", use_container_width=True)
        if st.session_state.bd_conectada:
            st.success("‚úÖ Conectado")
    return usuario, contrase√±a, servidor, base_datos, conectar

@st.cache_data(ttl=900, show_spinner=False)
def cargar_datos(_usuario, _contrase√±a, _servidor, _base_datos):
    async def obtener():
        client = PostgresConversationClient(user=_usuario, password=_contrase√±a, host=_servidor, database=_base_datos)
        await client.connect()
        consulta = """
        SELECT
        m.*,
        c.title AS conversation_title,
        c.type AS conversation_type
        FROM messages m
        LEFT JOIN conversations c ON m.conversation_id = c.conversation_id
        ORDER BY m."createdAt" DESC
        """
        resultados = await client.conn.fetch(consulta)
        await client.close()
        df = pd.DataFrame([dict(fila) for fila in resultados])
        if not df.empty and "createdAt" in df.columns:
            df["createdAt"] = normalizar_fechas(df["createdAt"])
        return df
    return ejecutar_async(obtener())

# ==================== NUEVO APARTADO: AN√ÅLISIS DE CONVERSACIONES POR FEEDBACK ====================
@st.cache_data(ttl=300, show_spinner=False)
def obtener_conversaciones_por_feedback(_config_bd, tipos_feedback, fecha_inicio, fecha_fin):
    """Obtiene conversaciones COMPLETAS que tienen al menos un mensaje con el feedback especificado"""
    async def consulta():
        client = PostgresConversationClient(**_config_bd)
        await client.connect()

        # Primero, encontrar las conversaciones que tienen el feedback especificado
        condiciones = []
        parametros = [f"{fecha_inicio} 00:00:00+00:00", f"{fecha_fin} 23:59:59+00:00"]

        base_query = """
        SELECT DISTINCT m.conversation_id
        FROM messages m
        WHERE m."createdAt" BETWEEN $1 AND $2
        """

        if tipos_feedback and 'Sin feedback' not in tipos_feedback:
            marcadores = ', '.join([f'${i+3}' for i in range(len(tipos_feedback))])
            base_query += f" AND m.feedback IN ({marcadores})"
            parametros.extend(tipos_feedback)
        elif 'Sin feedback' in tipos_feedback and len(tipos_feedback) > 1:
            tipos_limpios = [t for t in tipos_feedback if t != 'Sin feedback']
            if tipos_limpios:
                marcadores = ', '.join([f'${i+3}' for i in range(len(tipos_limpios))])
                base_query += f" AND (m.feedback IN ({marcadores}) OR m.feedback IS NULL)"
                parametros.extend(tipos_limpios)
        elif 'Sin feedback' in tipos_feedback:
            base_query += " AND m.feedback IS NULL"

        # Obtener todas las conversaciones que coinciden
        conversaciones_query = f"""
        SELECT m.*, c.title AS conversation_title, c.type AS conversation_type
        FROM messages m
        LEFT JOIN conversations c ON m.conversation_id = c.conversation_id
        WHERE m.conversation_id IN ({base_query})
        AND m."createdAt" BETWEEN $1 AND $2
        ORDER BY m.conversation_id, m."createdAt"
        """

        resultados = await client.conn.fetch(conversaciones_query, *parametros)
        await client.close()
        df = pd.DataFrame([dict(fila) for fila in resultados])
        if not df.empty and "createdAt" in df.columns:
            df["createdAt"] = normalizar_fechas(df["createdAt"])
        return df
    return ejecutar_async(consulta())

def mostrar_analisis_conversaciones_feedback():
    """Nueva secci√≥n dedicada a an√°lisis de conversaciones por feedback"""
    st.markdown("## üîç An√°lisis de Conversaciones por Feedback")

    if st.session_state.datos is None:
        st.warning("‚ö†Ô∏è Primero debes conectar a la base de datos")
        return

    st.markdown('<div class="alerta-info">üìä Esta secci√≥n muestra conversaciones COMPLETAS basadas en el feedback de sus mensajes</div>', unsafe_allow_html=True)

    # Filtros espec√≠ficos para esta secci√≥n
    col1, col2, col3 = st.columns(3)

    with col1:
        try:
            fechas = pd.to_datetime(st.session_state.datos["createdAt"], errors='coerce').dropna()
            fecha_min = fechas.min().date() if not fechas.empty else datetime.now().date() - timedelta(days=30)
            fecha_max = fechas.max().date() if not fechas.empty else datetime.now().date()
        except:
            fecha_min = datetime.now().date() - timedelta(days=30)
            fecha_max = datetime.now().date()

        fecha_inicio = st.date_input("Fecha Inicio", fecha_min, key="fecha_inicio_feedback")
        fecha_fin = st.date_input("Fecha Fin", fecha_max, key="fecha_fin_feedback")

    with col2:
        tipos_feedback = []
        if "feedback" in st.session_state.datos.columns:
            opciones_feedback = list(st.session_state.datos["feedback"].dropna().unique()) + ["Sin feedback"]
            tipos_feedback = st.multiselect(
                "Tipos de Feedback a buscar",
                opciones_feedback,
                default=["positive", "negative"],
                key="tipos_feedback_especial"
            )

    with col3:
        st.markdown("<br>", unsafe_allow_html=True)
        analizar = st.button("üîç Buscar Conversaciones", type="primary", use_container_width=True)

    if analizar and tipos_feedback:
        with st.spinner("üîÑ Buscando conversaciones completas..."):
            try:
                df_conversaciones = obtener_conversaciones_por_feedback(
                    st.session_state.config_bd,
                    tipos_feedback,
                    fecha_inicio,
                    fecha_fin
                )

                if df_conversaciones.empty:
                    st.markdown('<div class="alerta-advertencia">‚ö†Ô∏è No se encontraron conversaciones con los filtros aplicados</div>', unsafe_allow_html=True)
                    return

                # Mostrar m√©tricas
                total_conversaciones = df_conversaciones["conversation_id"].nunique()
                total_mensajes = len(df_conversaciones)

                col1, col2, col3 = st.columns(3)
                with col1:
                    st.markdown(crear_metrica("Conversaciones Encontradas", f"{total_conversaciones:,}", "üó£Ô∏è", COLORES['primario']), unsafe_allow_html=True)
                with col2:
                    st.markdown(crear_metrica("Mensajes Totales", f"{total_mensajes:,}", "üí¨", COLORES['exito']), unsafe_allow_html=True)
                with col3:
                    usuarios = df_conversaciones["user_id"].nunique()
                    st.markdown(crear_metrica("Usuarios", f"{usuarios:,}", "üë•", COLORES['advertencia']), unsafe_allow_html=True)

                # Mostrar conversaciones con desplegables
                grupos = df_conversaciones.groupby("conversation_id")

                for conv_id, datos_conv in grupos:
                    # Resumen de la conversaci√≥n
                    titulo = datos_conv["conversation_title"].iloc[0] if pd.notna(datos_conv["conversation_title"].iloc[0]) else "Sin t√≠tulo"
                    usuario = datos_conv["user_id"].iloc[0]
                    fecha_inicio = datos_conv["createdAt"].min()
                    fecha_fin = datos_conv["createdAt"].max()
                    duracion = fecha_fin - fecha_inicio

                    # Contar feedbacks
                    feedback_counts = datos_conv["feedback"].fillna("Sin feedback").value_counts()
                    feedback_resumen = ", ".join([f"{k}: {v}" for k, v in feedback_counts.items()])

                    st.markdown(f"""
                    <div class="contenedor-conversacion">
                        <div class="encabezado-conversacion">
                            <div class="info-conversacion">
                                <div class="titulo-conversacion">üó£Ô∏è Conversaci√≥n {conv_id}</div>
                                <div class="meta-conversacion">üìã <strong>T√≠tulo:</strong> {titulo}</div>
                                <div class="meta-conversacion">üë§ <strong>Usuario:</strong> {usuario}</div>
                                <div class="meta-conversacion">üìÖ <strong>Duraci√≥n:</strong> {duracion}</div>
                                <div class="meta-conversacion">üìù <strong>Feedback:</strong> {feedback_resumen}</div>
                            </div>
                            <div class="etiqueta-conversacion">{len(datos_conv)} mensajes</div>
                        </div>
                    """, unsafe_allow_html=True)

                    # Desplegable con todos los mensajes
                    with st.expander(f"üëÅÔ∏è Ver conversaci√≥n completa ({len(datos_conv)} mensajes)", expanded=False):
                        for idx, (_, mensaje) in enumerate(datos_conv.iterrows(), 1):
                            rol = mensaje.get("role", "N/A").lower()
                            contenido = mensaje.get("content", "[Sin contenido]").strip()
                            timestamp = pd.to_datetime(mensaje.get("createdAt", "")).strftime("%Y-%m-%d %H:%M:%S")
                            feedback = mensaje.get("feedback", "Sin feedback")

                            clase_css = "mensaje-usuario" if rol == "user" else "mensaje-asistente" if rol == "assistant" else "mensaje-sistema"
                            icono = "üë§" if rol == "user" else "ü§ñ" if rol == "assistant" else "‚öôÔ∏è"

                            st.markdown(f"""
                            <div class="item-mensaje {clase_css}">
                                <div class="encabezado-mensaje">
                                    <div class="rol-mensaje">
                                        <span>{icono}</span>
                                        <span><strong>Mensaje #{idx} - {rol.title()}</strong></span>
                                        <span class="tiempo-mensaje">üïê {timestamp} | üìù Feedback: {feedback}</span>
                                    </div>
                                </div>
                                <div class="contenido-mensaje">{contenido}</div>
                            </div>
                            """, unsafe_allow_html=True)

                    st.markdown("</div>", unsafe_allow_html=True)
                    st.markdown("---")

            except Exception as e:
                st.error(f"‚ùå Error en el an√°lisis de conversaciones: {str(e)}")

# ==================== AN√ÅLISIS SIN FEEDBACK COMPLETO (MEJORADO) ====================
def analizar_conversaciones_sin_feedback(df):
    st.markdown("## üîç An√°lisis Completo de Conversaciones Sin Feedback")

    if "feedback" not in df.columns:
        st.info("‚ÑπÔ∏è No hay datos de feedback disponibles")
        return

    sin_feedback = df[df["feedback"].isna()].copy()
    if sin_feedback.empty:
        st.markdown('<div class="alerta-exito">‚úÖ <strong>¬°Excelente!</strong> Todas las conversaciones tienen feedback.</div>', unsafe_allow_html=True)
        return

    total_sin_feedback = len(sin_feedback)
    conversaciones_afectadas = sin_feedback["conversation_id"].nunique() if "conversation_id" in sin_feedback.columns else 0
    usuarios_afectados = sin_feedback["user_id"].nunique() if "user_id" in sin_feedback.columns else 0

    st.markdown(f'<div class="alerta-info">üìã <strong>{total_sin_feedback:,} mensajes sin feedback</strong> en <strong>{conversaciones_afectadas:,} conversaciones</strong> de <strong>{usuarios_afectados:,} usuarios</strong></div>', unsafe_allow_html=True)

    grupos_conversacion = sin_feedback.groupby("conversation_id")
    stats_conversaciones = sin_feedback.groupby("conversation_id").agg({
        "id": "count", "user_id": "first", "conversation_title": "first",
        "createdAt": ["min", "max"], "role": lambda x: list(x.unique()),
        "type": lambda x: list(x.unique())
    }).round(2)

    stats_conversaciones.columns = ["cantidad_mensajes", "id_usuario", "titulo", "tiempo_inicio", "tiempo_fin", "roles", "tipos"]
    stats_conversaciones = stats_conversaciones.sort_values("cantidad_mensajes", ascending=False)

    total_conversaciones = len(stats_conversaciones)
    conversaciones_por_pagina = st.selectbox("Conversaciones por p√°gina:", [5, 10, 15, 20, 30], index=2)

    if total_conversaciones > conversaciones_por_pagina:
        total_paginas = (total_conversaciones + conversaciones_por_pagina - 1) // conversaciones_por_pagina
        pagina_actual = st.selectbox(f"P√°gina (Total: {total_paginas}):", range(1, total_paginas + 1))
        indice_inicio = (pagina_actual - 1) * conversaciones_por_pagina
        indice_fin = indice_inicio + conversaciones_por_pagina
        stats_pagina = stats_conversaciones.iloc[indice_inicio:indice_fin]
        st.markdown(f'<div class="alerta-info">üìÑ Mostrando conversaciones {indice_inicio + 1} a {min(indice_fin, total_conversaciones)} de {total_conversaciones}</div>', unsafe_allow_html=True)
    else:
        stats_pagina = stats_conversaciones

    for posicion, (id_conversacion, estadisticas) in enumerate(stats_pagina.iterrows(), 1):
        datos_conversacion = grupos_conversacion.get_group(id_conversacion)

        if estadisticas['cantidad_mensajes'] > 15:
            nivel_prioridad = "üî¥ Cr√≠tica"
            color_prioridad = COLORES['peligro']
        elif estadisticas['cantidad_mensajes'] > 8:
            nivel_prioridad = "üü° Alta"
            color_prioridad = COLORES['advertencia']
        else:
            nivel_prioridad = "üü¢ Media"
            color_prioridad = COLORES['exito']

        st.markdown(f"""
        <div class="contenedor-conversacion">
            <div class="encabezado-conversacion">
                <div class="info-conversacion">
                    <div class="titulo-conversacion">üó£Ô∏è Conversaci√≥n {id_conversacion}</div>
                    <div class="meta-conversacion">üìã <strong>T√≠tulo:</strong> {estadisticas['titulo'] if pd.notna(estadisticas['titulo']) else 'Sin t√≠tulo'}</div>
                    <div class="meta-conversacion">üë§ <strong>Usuario:</strong> {estadisticas['id_usuario']} | üé≠ <strong>Roles:</strong> {', '.join(estadisticas['roles'])}</div>
                    <div class="meta-conversacion">üìÖ <strong>Per√≠odo:</strong> {pd.to_datetime(estadisticas['tiempo_inicio']).strftime('%Y-%m-%d %H:%M')} ‚Üí {pd.to_datetime(estadisticas['tiempo_fin']).strftime('%Y-%m-%d %H:%M')}</div>
                    <div class="meta-conversacion">‚ö†Ô∏è <strong>Prioridad:</strong> <span style="color: {color_prioridad}; font-weight: bold;">{nivel_prioridad}</span></div>
                </div>
                <div class="etiqueta-conversacion">{estadisticas['cantidad_mensajes']} mensajes</div>
            </div>
        """, unsafe_allow_html=True)

        duracion = pd.to_datetime(estadisticas['tiempo_fin']) - pd.to_datetime(estadisticas['tiempo_inicio'])
        resumen_tipos = dict(datos_conversacion['type'].value_counts())
        promedio_diario = estadisticas['cantidad_mensajes'] / max(1, duracion.days) if duracion.days > 0 else estadisticas['cantidad_mensajes']

        st.markdown(f"""
        <div class="resumen-conversacion">
            <strong>üìä Resumen de la Conversaci√≥n</strong>
            <div class="cuadricula-resumen">
                <div class="item-resumen"><strong>‚è±Ô∏è Duraci√≥n:</strong><br>{duracion}</div>
                <div class="item-resumen"><strong>üìù Tipos √∫nicos:</strong><br>{len(resumen_tipos)}</div>
                <div class="item-resumen"><strong>üé≠ Roles:</strong><br>{len(estadisticas['roles'])}</div>
                <div class="item-resumen"><strong>üìä Promedio/d√≠a:</strong><br>{promedio_diario:.1f}</div>
            </div>
        </div>
        """, unsafe_allow_html=True)

        with st.expander(f"üëÅÔ∏è Ver los {estadisticas['cantidad_mensajes']} mensajes de la conversaci√≥n {id_conversacion}", expanded=False):
            mensajes_ordenados = datos_conversacion.sort_values("createdAt")

            for indice_mensaje, (_, mensaje) in enumerate(mensajes_ordenados.iterrows(), 1):
                rol = mensaje.get("role", "N/A").lower()
                contenido_raw = mensaje.get("content", "[Sin contenido]").strip()
                contenido = formatear_mensaje_tool(contenido_raw, mensaje.get("metadata"))
                timestamp = pd.to_datetime(mensaje.get("createdAt", "")).strftime("%Y-%m-%d %H:%M:%S")
                tipo_mensaje = mensaje.get("type", "general")
                id_usuario = mensaje.get("user_id", "desconocido")

                if rol == "user":
                    clase_css = "mensaje-usuario"
                    icono = "üë§"
                    nombre_rol = "Usuario"
                elif rol == "assistant":
                    clase_css = "mensaje-asistente"
                    icono = "ü§ñ"
                    nombre_rol = "Asistente"
                else:
                    clase_css = "mensaje-sistema"
                    icono = "‚öôÔ∏è"
                    nombre_rol = "Sistema"

                st.markdown(f"""
                <div class="item-mensaje {clase_css}">
                    <div class="encabezado-mensaje">
                        <div class="rol-mensaje">
                            <span>{icono}</span>
                            <span><strong>Mensaje #{indice_mensaje} - {nombre_rol}</strong></span>
                            <span style="font-size:0.8rem;color:#6c757d;">({tipo_mensaje})</span>
                        </div>
                        <div class="tiempo-mensaje">üïê {timestamp} | üë§ {id_usuario}</div>
                    </div>
                    <div class="contenido-mensaje">
                        <strong>üí¨ Contenido:</strong><br>
                        {contenido[:1000]}{'...' if len(contenido) > 1000 else ''}
                    </div>
                """, unsafe_allow_html=True)

                campos_tecnicos = {
                    "question": "‚ùì Pregunta", "expected_response": "üìå Respuesta Esperada",
                    "expected_documents": "üìé Documentos Esperados", "function_call": "‚öôÔ∏è Funci√≥n",
                    "llm_filters": "üîç Filtros LLM", "source_documents": "üìö Documentos",
                    "feedback_content": "üí≠ Contenido Feedback"
                }

                tiene_info_tecnica = False
                html_tecnico = '<div class="info-tecnica-mensaje"><strong>üîß Informaci√≥n T√©cnica:</strong><br>'

                for campo, etiqueta in campos_tecnicos.items():
                    valor_campo = mensaje.get(campo)
                    if valor_campo and str(valor_campo).strip() not in ['', 'nan', 'None', 'null']:
                        tiene_info_tecnica = True
                        valor_mostrar = str(valor_campo)[:400] + ('...' if len(str(valor_campo)) > 400 else '')
                        html_tecnico += f'<div class="campo-tecnico"><span class="etiqueta-campo">{etiqueta}:</span><span class="valor-campo">{valor_mostrar}</span></div>'

                html_tecnico += '</div>'
                if tiene_info_tecnica:
                    st.markdown(html_tecnico, unsafe_allow_html=True)

                st.markdown("</div>", unsafe_allow_html=True)

        st.markdown("</div>", unsafe_allow_html=True)
        st.markdown("---")

# ==================== FORMATEADOR UNIVERSAL PARA MENSAJES TOOL ====================
def formatear_mensaje_tool(contenido, metadata=None):
    # [El c√≥digo del formateador permanece igual...]
    # (Se mantiene el mismo c√≥digo original para mantener la respuesta corta)
    return str(contenido)  # Placeholder - usa el c√≥digo original completo aqu√≠

# ==================== MEN√ö LATERAL CON NUEVA OPCI√ìN ====================
def mostrar_menu_lateral():
    with st.sidebar:
        st.markdown("### üéØ Modo de An√°lisis")
        modo_analisis = st.radio(
            "Selecciona el tipo de an√°lisis:",
            ["An√°lisis General", "An√°lisis de Conversaciones por Feedback"],
            index=0
        )
        return modo_analisis

# ==================== APLICACI√ìN PRINCIPAL ====================
def main():
    aplicar_estilos()
    
    # Encabezado din√°mico sin mostrar usuario
    st.markdown(f"""
    <div class="encabezado-principal">
        <h1 style="margin: 0; font-size: 2.5rem;">üìä RAN AVAD Analytics Dashboard</h1>
        <p style="margin: 0.5rem 0 0 0; opacity: 0.9; font-size: 1.2rem;">
            M√©tricas completas - WebApp
        </p>
        <p style="margin: 0.3rem 0 0 0; font-size: 0.9rem; opacity: 0.8;">
            üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Conexi√≥n BD
    usuario, contrase√±a, servidor, base_datos, conectar = mostrar_conexion()

    if conectar:
        with st.spinner("üîÑ Conectando y cargando datos completos..."):
            try:
                tiempo_inicio = datetime.now()
                datos_completos = cargar_datos(usuario, contrase√±a, servidor, base_datos)
                tiempo_carga = (datetime.now() - tiempo_inicio).total_seconds()

                st.session_state.datos = datos_completos
                st.session_state.config_bd = {"user": usuario, "password": contrase√±a, "host": servidor, "database": base_datos}
                st.session_state.bd_conectada = True

                st.markdown(f'<div class="alerta-exito">‚úÖ <strong>Conexi√≥n exitosa!</strong> Cargados {len(datos_completos):,} registros en {tiempo_carga:.2f}s</div>', unsafe_allow_html=True)

            except Exception as e:
                st.markdown(f'<div class="alerta-advertencia">‚ùå <strong>Error:</strong> {str(e)}</div>', unsafe_allow_html=True)
                st.session_state.bd_conectada = False

    # NUEVO MEN√ö LATERAL
    modo_analisis = mostrar_menu_lateral()

    # L√≥gica seg√∫n el modo seleccionado
    if st.session_state.datos is not None:
        if modo_analisis == "An√°lisis General":
            # [El resto del c√≥digo original del an√°lisis general permanece igual...]
            st.markdown("### üìä An√°lisis General")
            # Incluye el c√≥digo original completo aqu√≠
            
        else:  # "An√°lisis de Conversaciones por Feedback"
            mostrar_analisis_conversaciones_feedback()

    # Panel estado sin mostrar usuarios
    with st.sidebar:
        st.markdown("---")
        st.markdown("### üìä Estado del Sistema")
        items_estado = [
            ("üïê Hora", datetime.now().strftime('%H:%M:%S')),
            ("üîó BD", "‚úÖ Conectada" if st.session_state.bd_conectada else "‚ùå Desconectada"),
            ("üìä Datos", f"‚úÖ {len(st.session_state.datos):,}" if st.session_state.datos is not None else "‚ùå Sin datos"),
            ("üìã Resultados", f"‚úÖ {len(st.session_state.resultados):,}" if st.session_state.resultados is not None else "‚ùå Sin an√°lisis")
        ]

        for etiqueta, valor in items_estado:
            st.markdown(f"**{etiqueta}:** {valor}")

        if st.button("üîÑ Actualizar Cache"):
            st.cache_data.clear()
            st.success("‚úÖ Cache actualizada")
            st.rerun()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        st.error(f"‚ùå **Error cr√≠tico:** {str(e)}")
        st.markdown("**üîß Soluci√≥n:** Recarga la p√°gina (F5)")
        if st.button("üÜò Reiniciar"):
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.cache_data.clear()
            st.rerun()
