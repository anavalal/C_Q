# En el archivo principal de tu aplicaci√≥n (donde se define la conexi√≥n a la base de datos)

def cargar_datos(_usuario, _contrase√±a, _servidor, _base_datos):
    async def obtener():
        client = PostgresConversationClient(user=_usuario, password=_contrase√±a, host=_servidor, database=_base_datos)
        await client.connect()
        consulta = """
        SELECT m.*, c.title AS conversation_title, c.type AS conversation_type
        FROM messages m
        LEFT JOIN conversations c ON m.conversation_id = c.conversation_id
        ORDER BY m."createdAt" DESC
        """
        resultados = await client.conn.fetch(consulta)
        await client.close()
        df = pd.DataFrame([dict(fila) for fila in resultados])
        if not df.empty and "createdAt" in df.columns:
            df["createdAt"] = pd.to_datetime(df["createdAt"], errors='coerce', utc=True)
        return df
    return ejecutar_async(obtener())




# En el archivo principal de tu aplicaci√≥n (donde se definen los filtros y el panel de control)

def mostrar_filtros(df):
    st.markdown("## üéõÔ∏è Panel de Filtros")
    if df.empty:
        st.warning("‚ö†Ô∏è No hay datos disponibles")
        return None, False

    st.markdown(f'<div class="alerta-info">üìä <strong>Datos cargados:</strong> {len(df):,} registros totales disponibles</div>', unsafe_allow_html=True)

    st.markdown('<div class="caja-filtros">', unsafe_allow_html=True)
    st.markdown("### üìÖ Per√≠odo de An√°lisis")
    try:
        fechas = pd.to_datetime(df["createdAt"], errors='coerce').dropna()
        fecha_min = fechas.min().date() if not fechas.empty else datetime.now().date() - timedelta(days=30)
        fecha_max = fechas.max().date() if not fechas.empty else datetime.now().date()
    except:
        fecha_min = datetime.now().date() - timedelta(days=30)
        fecha_max = datetime.now().date()

    col1, col2 = st.columns(2)
    with col1:
        fecha_inicio = st.date_input("Fecha de Inicio", fecha_min, min_value=fecha_min, max_value=fecha_max)
    with col2:
        fecha_fin = st.date_input("Fecha de Fin", fecha_max, min_value=fecha_min, max_value=fecha_max)
    st.markdown('</div>', unsafe_allow_html=True)

    try:
        offset = pd.Timedelta(hours=2)
        inicio_dt = (pd.Timestamp(fecha_inicio) + offset).tz_localize('UTC')
        fin_dt = (pd.Timestamp(fecha_fin) + pd.Timedelta(hours=23, minutes=59, seconds=59) + offset).tz_localize('UTC')

        st.session_state.df_filtrado = df[(df["createdAt"] >= inicio_dt) & (df["createdAt"] <= fin_dt)]
        df_filtrado = st.session_state.df_filtrado

        st.sidebar.caption(f"üîç Filtrando: {inicio_dt.strftime('%Y-%m-%d %H:%M')} ‚Üí {fin_dt.strftime('%Y-%m-%d %H:%M')} UTC")
    except Exception as e:
        st.error(f"Error filtrando fechas: {e}")
        st.session_state.df_filtrado = df
        df_filtrado = st.session_state.df_filtrado

    if df_filtrado.empty:
        st.warning("‚ö†Ô∏è Sin datos en el per√≠odo seleccionado")
        return None, False

    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.markdown(crear_metrica("Total Mensajes", f"{len(df_filtrado):,}", "üí¨"), unsafe_allow_html=True)
    with col2:
        usuarios = df_filtrado["user_id"].nunique() if "user_id" in df_filtrado.columns else 0
        st.markdown(crear_metrica("Usuarios √önicos", f"{usuarios:,}", "üë•", COLORES['exito']), unsafe_allow_html=True)
    with col3:
        conversaciones = df_filtrado["conversation_id"].nunique() if "conversation_id" in df_filtrado.columns else 0
        st.markdown(crear_metrica("Conversaciones", f"{conversaciones:,}", "üó£Ô∏è", COLORES['advertencia']), unsafe_allow_html=True)
    with col4:
        if "feedback" in df_filtrado.columns:
            con_feedback = df_filtrado["feedback"].notna().sum()
            porc_feedback = (con_feedback / len(df_filtrado) * 100) if len(df_filtrado) > 0 else 0
            color = COLORES['exito'] if porc_feedback >= 70 else COLORES['advertencia'] if porc_feedback >= 40 else COLORES['peligro']
            st.markdown(crear_metrica("Con Feedback", f"{porc_feedback:.1f}%", "üìù", color), unsafe_allow_html=True)
        else:
            st.markdown(crear_metrica("Con Feedback", "N/A", "üìù", COLORES['secundario']), unsafe_allow_html=True)

    filtros = {'fecha_inicio': fecha_inicio, 'fecha_fin': fecha_fin}
    with st.expander("üîß Filtros Avanzados", expanded=False):
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("**üë• Filtros de Usuario y Rol**")
            if "user_id" in df_filtrado.columns:
                filtros['usuarios'] = st.multiselect("Seleccionar Usuarios", sorted(df_filtrado["user_id"].dropna().unique()))
            if "role" in df_filtrado.columns:
                filtros['roles'] = st.multiselect("Seleccionar Roles", sorted(df_filtrado["role"].dropna().unique()))
        with col2:
            st.markdown("**üó£Ô∏è Filtros de Interacci√≥n**")
            if "feedback" in df_filtrado.columns:
                opciones_feedback = list(df_filtrado["feedback"].dropna().unique()) + ["Sin feedback"]
                filtros['feedback'] = st.multiselect("Tipo de Feedback", opciones_feedback)
            if "type" in df_filtrado.columns:
                filtros['tipos'] = st.multiselect("Tipos de Mensaje", sorted(df_filtrado["type"].dropna().unique()))

    st.markdown('<div class="caja-filtros">', unsafe_allow_html=True)
    st.markdown("### ‚öôÔ∏è Configuraci√≥n del An√°lisis")
    col1, col2 = st.columns(2)
    with col1:
        todas_columnas = ["id", "createdAt", "updatedAt", "user_id", "conversation_id", "role", "type",
                         "content", "feedback", "feedback_content", "expected_response",
                         "expected_documents", "function_call", "question", "llm_filters",
                         "source_documents", "conversation_title", "conversation_type"]
        filtros['mostrar_columnas'] = st.multiselect("Columnas a Mostrar", todas_columnas,
                                                    default=["createdAt", "user_id", "role", "feedback", "content"])
    with col2:
        filtros['mostrar_sin_feedback'] = st.checkbox("Incluir An√°lisis Sin Feedback", value=True)
        filtros['solo_completos'] = st.checkbox("Solo Registros Completos")
    st.markdown('</div>', unsafe_allow_html=True)

    ejecutar = st.button("üöÄ **Ejecutar An√°lisis Completo**", type="primary", use_container_width=True)
    return filtros, ejecutar





# En el archivo principal de tu aplicaci√≥n (dentro de la secci√≥n de administraci√≥n o utilidades)

async def actualizar_user_ids(user_map):
    client = PostgresConversationClient(**st.session_state.config_bd)
    await client.connect()
    for old, new in user_map.items():
        if new.strip():
            await client.conn.execute(
                "UPDATE messages SET user_id = $1 WHERE user_id = $2",
                new.strip(), old
            )
    await client.close()


