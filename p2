# ==================== FUNCIONES ADMIN SEMI-AUTOM√ÅTICAS ====================
async def detectar_userids_no_legibles():
    """Devuelve los user_id que NO parecen nombres reales"""
    client = PostgresConversationClient(**st.session_state.config_bd)
    await client.connect()
    rows = await client.conn.fetch("SELECT DISTINCT user_id FROM messages WHERE user_id IS NOT NULL")
    await client.close()
    return [
        str(r["user_id"]) for r in rows
        if (
            " " not in str(r["user_id"])
            or len(str(r["user_id"])) < 4
            or str(r["user_id"]).count("-") >= 3
            or str(r["user_id"]).isdigit()
        )
    ]

async def actualizar_user_ids(user_map):
    """Ejecuta UPDATEs con el mapeo recibido"""
    client = PostgresConversationClient(**st.session_state.config_bd)
    await client.connect()
    for old, new in user_map.items():
        if new.strip():
            await client.conn.execute(
                "UPDATE messages SET user_id = $1 WHERE user_id = $2",
                new.strip(), old
            )
    await client.close()

def generar_csv_mapeo(userids):
    """Devuelve CSV descargable con columnas User_ID,Nombre_Real"""
    df = pd.DataFrame({"User_ID": userids, "Nombre_Real": [""] * len(userids)})
    return df.to_csv(index=False, encoding="utf-8-sig", sep=";")

def cargar_csv_mapeo(uploaded_file):
    """Lee CSV y devuelve dict {User_ID:Nombre_Real}"""
    df = pd.read_csv(uploaded_file, sep=";", encoding="utf-8-sig")
    return dict(zip(df["User_ID"].astype(str), df["Nombre_Real"].astype(str)))





    # ===== PANEL ADMIN SEMI-AUTOM√ÅTICO =====
    if st.session_state.bd_conectada:
        with st.sidebar.expander("üîß Admin - Renombrar user_id", expanded=False):
            clave = st.text_input("Clave admin", type="password", key="clave_admin")
            if clave == "avad2025":
                try:
                    userids = ejecutar_async(detectar_userids_no_legibles())
                    if not userids:
                        st.success("‚úÖ Todos los user_id ya son legibles")
                    else:
                        st.info(f"üìã {len(userids)} user_id pendientes")
                        tab1, tab2 = st.tabs(["Formulario", "Export / Import CSV"])
                        with tab1:
                            df_map = pd.DataFrame({"User_ID_actual": userids, "Nombre_Real": [""]*len(userids)})
                            edited = st.data_editor(df_map, use_container_width=True, key="editor")
                            if st.button("üíæ Confirmar cambios"):
                                mapeo = dict(zip(edited["User_ID_actual"], edited["Nombre_Real"]))
                                mapeo = {k: v for k, v in mapeo.items() if str(v).strip()}
                                if mapeo:
                                    with st.spinner("Actualizando..."):
                                        ejecutar_async(actualizar_user_ids(mapeo))
                                        st.cache_data.clear()
                                        st.success("‚úÖ Actualizado. Recarga la p√°gina.")
                                else:
                                    st.warning("‚ö†Ô∏è Rellena al menos un nombre")
                        with tab2:
                            csv_plantilla = generar_csv_mapeo(userids)
                            st.download_button("üì• Descargar plantilla CSV", csv_plantilla, "mapeo_user_id.csv", "text/csv")
                            uploaded = st.file_uploader("Subir CSV actualizado", type="csv")
                            if uploaded:
                                mapeo = cargar_csv_mapeo(uploaded)
                                if st.button("üíæ Aplicar CSV"):
                                    with st.spinner("Actualizando..."):
                                        ejecutar_async(actualizar_user_ids(mapeo))
                                        st.cache_data.clear()
                                        st.success("‚úÖ CSV aplicado. Recarga la p√°gina.")
                except Exception as e:
                    st.error(f"Error: {e}")
            elif clave:
                st.error("‚ùå Clave incorrecta")


























def mostrar_filtros(df):
    st.markdown("## üéõÔ∏è Panel de Filtros")
    if df.empty:
        st.warning("‚ö†Ô∏è No hay datos disponibles")
        return None, False

    st.markdown(f'<div class="alerta-info">üìä <strong>Datos cargados:</strong> {len(df):,} registros totales disponibles</div>', unsafe_allow_html=True)

    # Filtro temporal
    st.markdown('<div class="caja-filtros">', unsafe_allow_html=True)
    st.markdown("### üìÖ Per√≠odo de An√°lisis")
    try:
        fechas = pd.to_datetime(df["createdAt"], errors='coerce').dropna()
        fecha_min = fechas.min().date() if not fechas.empty else datetime.now().date() - timedelta(days=30)
        fecha_max = fechas.max().date() if not fechas.empty else datetime.now().date()
    except:
        fecha_min = datetime.now().date() - timedelta(days=30)
        fecha_max = datetime.now().date()

    col1, col2 = st.columns(2)
    with col1:
        fecha_inicio = st.date_input("Fecha de Inicio", fecha_min, min_value=fecha_min, max_value=fecha_max)
    with col2:
        fecha_fin = st.date_input("Fecha de Fin", fecha_max, min_value=fecha_min, max_value=fecha_max)
    st.markdown('</div>', unsafe_allow_html=True)

    # Aplicar filtro temporal
    try:
        inicio_dt = pd.Timestamp(fecha_inicio, tz='UTC')
        fin_dt = pd.Timestamp(fecha_fin, tz='UTC') + pd.Timedelta(hours=23, minutes=59, seconds=59)
        df_filtrado = df[(df["createdAt"] >= inicio_dt) & (df["createdAt"] <= fin_dt)]
    except:
        df_filtrado = df

    if df_filtrado.empty:
        st.warning("‚ö†Ô∏è Sin datos en el per√≠odo seleccionado")
        return None, False

    # M√©tricas del per√≠odo
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.markdown(crear_metrica("Total Mensajes", f"{len(df_filtrado):,}", "üí¨"), unsafe_allow_html=True)
    with col2:
        usuarios = df_filtrado["user_id"].nunique() if "user_id" in df_filtrado.columns else 0
        st.markdown(crear_metrica("Usuarios √önicos", f"{usuarios:,}", "üë•", COLORES['exito']), unsafe_allow_html=True)
    with col3:
        conversaciones = df_filtrado["conversation_id"].nunique() if "conversation_id" in df_filtrado.columns else 0
        st.markdown(crear_metrica("Conversaciones", f"{conversaciones:,}", "üó£Ô∏è", COLORES['advertencia']), unsafe_allow_html=True)
    with col4:
        if "feedback" in df_filtrado.columns:
            con_feedback = df_filtrado["feedback"].notna().sum()
            porc_feedback = (con_feedback / len(df_filtrado) * 100) if len(df_filtrado) > 0 else 0
            color = COLORES['exito'] if porc_feedback >= 70 else COLORES['advertencia'] if porc_feedback >= 40 else COLORES['peligro']
            st.markdown(crear_metrica("Con Feedback", f"{porc_feedback:.1f}%", "üìù", color), unsafe_allow_html=True)
        else:
            st.markdown(crear_metrica("Con Feedback", "N/A", "üìù", COLORES['secundario']), unsafe_allow_html=True)

    # Filtros adicionales
    filtros = {'fecha_inicio': fecha_inicio, 'fecha_fin': fecha_fin}
    with st.expander("üîß Filtros Avanzados", expanded=False):
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("**üë• Filtros de Usuario y Rol**")
            if "user_id" in df_filtrado.columns:
                filtros['usuarios'] = st.multiselect("Seleccionar Usuarios", sorted(df_filtrado["user_id"].dropna().unique()))
            if "role" in df_filtrado.columns:
                filtros['roles'] = st.multiselect("Seleccionar Roles", sorted(df_filtrado["role"].dropna().unique()))
        with col2:
            st.markdown("**üó£Ô∏è Filtros de Interacci√≥n**")
            if "feedback" in df_filtrado.columns:
                opciones_feedback = list(df_filtrado["feedback"].dropna().unique()) + ["Sin feedback"]
                filtros['feedback'] = st.multiselect("Tipo de Feedback", opciones_feedback)
            if "type" in df_filtrado.columns:
                filtros['tipos'] = st.multiselect("Tipos de Mensaje", sorted(df_filtrado["type"].dropna().unique()))

    # Configuraci√≥n
    st.markdown('<div class="caja-filtros">', unsafe_allow_html=True)
    st.markdown("### ‚öôÔ∏è Configuraci√≥n del An√°lisis")
    col1, col2 = st.columns(2)
    with col1:
        todas_columnas = ["id", "createdAt", "updatedAt", "user_id", "conversation_id", "role", "type",
                         "content", "feedback", "feedback_content", "expected_response",
                         "expected_documents", "function_call", "question", "llm_filters",
                         "source_documents", "conversation_title", "conversation_type"]
        filtros['mostrar_columnas'] = st.multiselect("Columnas a Mostrar", todas_columnas,
                                                    default=["createdAt", "user_id", "role", "feedback", "content"])
    with col2:
        filtros['mostrar_sin_feedback'] = st.checkbox("Incluir An√°lisis Sin Feedback", value=True)
        filtros['solo_completos'] = st.checkbox("Solo Registros Completos")
    st.markdown('</div>', unsafe_allow_html=True)

    ejecutar = st.button("üöÄ **Ejecutar An√°lisis Completo**", type="primary", use_container_width=True)
    return filtros, ejecutar

-----------------------
def main():
    # Auto-refresco cada 5 minutos (opcional)
    if 'last_refresh' not in st.session_state:
        st.session_state.last_refresh = datetime.now()

    if st.sidebar.button("üîÑ Refrescar Datos Ahora"):
        st.cache_data.clear()
        st.session_state.last_refresh = datetime.now()
        st.rerun()

    # Refresco autom√°tico cada 5 minutos
    if (datetime.now() - st.session_state.last_refresh).seconds > 300:
        st.cache_data.clear()
        st.session_state.last_refresh = datetime.now()
        st.rerun()



@st.cache_data(ttl=30, show_spinner=False)  # Refresco cada 30 segundos


with st.sidebar:
    st.markdown("**√öltima actualizaci√≥n:**")
    st.markdown(f"`{st.session_state.last_refresh.strftime('%H:%M:%S')}`")

st.session_state.df_filtrado = df[...]
