try:
    # Conversi√≥n manual para zona horaria Madrid (UTC+2 en verano)
    offset = pd.Timedelta(hours=2)
    inicio_dt = (pd.Timestamp(fecha_inicio) + offset).tz_localize('UTC')
    fin_dt = (pd.Timestamp(fecha_fin) + pd.Timedelta(hours=23, minutes=59, seconds=59) + offset).tz_localize('UTC')
    
    st.session_state.df_filtrado = df[(df["createdAt"] >= inicio_dt) & (df["createdAt"] <= fin_dt)]
    df_filtrado = st.session_state.df_filtrado
    
    # Debug: Mostrar rangos
    st.sidebar.caption(f"üîç Filtrando: {inicio_dt.strftime('%Y-%m-%d %H:%M')} ‚Üí {fin_dt.strftime('%Y-%m-%d %H:%M')} UTC")
except Exception as e:
    st.error(f"Error filtrando fechas: {e}")
    st.session_state.df_filtrado = df
    df_filtrado = st.session_state.df_filtrado



with st.sidebar:
    if st.session_state.datos is not None and not st.session_state.datos.empty:
        ultimo_mensaje = st.session_state.datos["createdAt"].max()
        st.caption(f"üìÖ √öltimo mensaje en BD: {ultimo_mensaje.strftime('%Y-%m-%d %H:%M')} UTC")
































def mostrar_filtros(df):
    st.markdown("## üéõÔ∏è Panel de Filtros")
    if df.empty:
        st.warning("‚ö†Ô∏è No hay datos disponibles")
        return None, False

    st.markdown(f'<div class="alerta-info">üìä <strong>Datos cargados:</strong> {len(df):,} registros totales disponibles</div>', unsafe_allow_html=True)

    # Filtro temporal
    st.markdown('<div class="caja-filtros">', unsafe_allow_html=True)
    st.markdown("### üìÖ Per√≠odo de An√°lisis")
    try:
        fechas = pd.to_datetime(df["createdAt"], errors='coerce').dropna()
        fecha_min = fechas.min().date() if not fechas.empty else datetime.now().date() - timedelta(days=30)
        fecha_max = fechas.max().date() if not fechas.empty else datetime.now().date()
    except:
        fecha_min = datetime.now().date() - timedelta(days=30)
        fecha_max = datetime.now().date()

    col1, col2 = st.columns(2)
    with col1:
        fecha_inicio = st.date_input("Fecha de Inicio", fecha_min, min_value=fecha_min, max_value=fecha_max)
    with col2:
        fecha_fin = st.date_input("Fecha de Fin", fecha_max, min_value=fecha_min, max_value=fecha_max)
    st.markdown('</div>', unsafe_allow_html=True)

    # Aplicar filtro temporal
    try:
        inicio_dt = pd.Timestamp(fecha_inicio, tz='UTC')
        fin_dt = pd.Timestamp(fecha_fin, tz='UTC') + pd.Timedelta(hours=23, minutes=59, seconds=59)
        df_filtrado = df[(df["createdAt"] >= inicio_dt) & (df["createdAt"] <= fin_dt)]
    except:
        df_filtrado = df

    if df_filtrado.empty:
        st.warning("‚ö†Ô∏è Sin datos en el per√≠odo seleccionado")
        return None, False

    # M√©tricas del per√≠odo
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.markdown(crear_metrica("Total Mensajes", f"{len(df_filtrado):,}", "üí¨"), unsafe_allow_html=True)
    with col2:
        usuarios = df_filtrado["user_id"].nunique() if "user_id" in df_filtrado.columns else 0
        st.markdown(crear_metrica("Usuarios √önicos", f"{usuarios:,}", "üë•", COLORES['exito']), unsafe_allow_html=True)
    with col3:
        conversaciones = df_filtrado["conversation_id"].nunique() if "conversation_id" in df_filtrado.columns else 0
        st.markdown(crear_metrica("Conversaciones", f"{conversaciones:,}", "üó£Ô∏è", COLORES['advertencia']), unsafe_allow_html=True)
    with col4:
        if "feedback" in df_filtrado.columns:
            con_feedback = df_filtrado["feedback"].notna().sum()
            porc_feedback = (con_feedback / len(df_filtrado) * 100) if len(df_filtrado) > 0 else 0
            color = COLORES['exito'] if porc_feedback >= 70 else COLORES['advertencia'] if porc_feedback >= 40 else COLORES['peligro']
            st.markdown(crear_metrica("Con Feedback", f"{porc_feedback:.1f}%", "üìù", color), unsafe_allow_html=True)
        else:
            st.markdown(crear_metrica("Con Feedback", "N/A", "üìù", COLORES['secundario']), unsafe_allow_html=True)

    # Filtros adicionales
    filtros = {'fecha_inicio': fecha_inicio, 'fecha_fin': fecha_fin}
    with st.expander("üîß Filtros Avanzados", expanded=False):
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("**üë• Filtros de Usuario y Rol**")
            if "user_id" in df_filtrado.columns:
                filtros['usuarios'] = st.multiselect("Seleccionar Usuarios", sorted(df_filtrado["user_id"].dropna().unique()))
            if "role" in df_filtrado.columns:
                filtros['roles'] = st.multiselect("Seleccionar Roles", sorted(df_filtrado["role"].dropna().unique()))
        with col2:
            st.markdown("**üó£Ô∏è Filtros de Interacci√≥n**")
            if "feedback" in df_filtrado.columns:
                opciones_feedback = list(df_filtrado["feedback"].dropna().unique()) + ["Sin feedback"]
                filtros['feedback'] = st.multiselect("Tipo de Feedback", opciones_feedback)
            if "type" in df_filtrado.columns:
                filtros['tipos'] = st.multiselect("Tipos de Mensaje", sorted(df_filtrado["type"].dropna().unique()))

    # Configuraci√≥n
    st.markdown('<div class="caja-filtros">', unsafe_allow_html=True)
    st.markdown("### ‚öôÔ∏è Configuraci√≥n del An√°lisis")
    col1, col2 = st.columns(2)
    with col1:
        todas_columnas = ["id", "createdAt", "updatedAt", "user_id", "conversation_id", "role", "type",
                         "content", "feedback", "feedback_content", "expected_response",
                         "expected_documents", "function_call", "question", "llm_filters",
                         "source_documents", "conversation_title", "conversation_type"]
        filtros['mostrar_columnas'] = st.multiselect("Columnas a Mostrar", todas_columnas,
                                                    default=["createdAt", "user_id", "role", "feedback", "content"])
    with col2:
        filtros['mostrar_sin_feedback'] = st.checkbox("Incluir An√°lisis Sin Feedback", value=True)
        filtros['solo_completos'] = st.checkbox("Solo Registros Completos")
    st.markdown('</div>', unsafe_allow_html=True)

    ejecutar = st.button("üöÄ **Ejecutar An√°lisis Completo**", type="primary", use_container_width=True)
    return filtros, ejecutar

-----------------------
def main():
    # Auto-refresco cada 5 minutos (opcional)
    if 'last_refresh' not in st.session_state:
        st.session_state.last_refresh = datetime.now()

    if st.sidebar.button("üîÑ Refrescar Datos Ahora"):
        st.cache_data.clear()
        st.session_state.last_refresh = datetime.now()
        st.rerun()

    # Refresco autom√°tico cada 5 minutos
    if (datetime.now() - st.session_state.last_refresh).seconds > 300:
        st.cache_data.clear()
        st.session_state.last_refresh = datetime.now()
        st.rerun()



@st.cache_data(ttl=30, show_spinner=False)  # Refresco cada 30 segundos


with st.sidebar:
    st.markdown("**√öltima actualizaci√≥n:**")
    st.markdown(f"`{st.session_state.last_refresh.strftime('%H:%M:%S')}`")

st.session_state.df_filtrado = df[...]
