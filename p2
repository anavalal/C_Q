# ==================== NUEVO APARTADO: AN√ÅLISIS DE CONVERSACIONES POR FEEDBACK ====================
@st.cache_data(ttl=300, show_spinner=False)
def obtener_conversaciones_por_feedback(_config_bd, tipos_feedback, fecha_inicio, fecha_fin):
    """Obtiene conversaciones COMPLETAS que tienen al menos un mensaje con el feedback especificado"""
    async def consulta():
        client = PostgresConversationClient(**_config_bd)
        await client.connect()

        # Primero, encontrar las conversaciones que tienen el feedback especificado
        condiciones = []
        parametros = [f"{fecha_inicio} 00:00:00+00:00", f"{fecha_fin} 23:59:59+00:00"]

        base_query = """
        SELECT DISTINCT m.conversation_id
        FROM messages m
        WHERE m."createdAt" BETWEEN $1 AND $2
        """

        if tipos_feedback and 'Sin feedback' not in tipos_feedback:
            marcadores = ', '.join([f'${i+3}' for i in range(len(tipos_feedback))])
            base_query += f" AND m.feedback IN ({marcadores})"
            parametros.extend(tipos_feedback)
        elif 'Sin feedback' in tipos_feedback and len(tipos_feedback) > 1:
            tipos_limpios = [t for t in tipos_feedback if t != 'Sin feedback']
            if tipos_limpios:
                marcadores = ', '.join([f'${i+3}' for i in range(len(tipos_limpios))])
                base_query += f" AND (m.feedback IN ({marcadores}) OR m.feedback IS NULL)"
                parametros.extend(tipos_limpios)
        elif 'Sin feedback' in tipos_feedback:
            base_query += " AND m.feedback IS NULL"

        # Obtener todas las conversaciones que coinciden
        conversaciones_query = f"""
        SELECT m.*, c.title AS conversation_title, c.type AS conversation_type
        FROM messages m
        LEFT JOIN conversations c ON m.conversation_id = c.conversation_id
        WHERE m.conversation_id IN ({base_query})
        AND m."createdAt" BETWEEN $1 AND $2
        ORDER BY m.conversation_id, m."createdAt"
        """

        resultados = await client.conn.fetch(conversaciones_query, *parametros)
        await client.close()
        df = pd.DataFrame([dict(fila) for fila in resultados])
        if not df.empty and "createdAt" in df.columns:
            df["createdAt"] = normalizar_fechas(df["createdAt"])
        return df
    return ejecutar_async(consulta())

def mostrar_analisis_conversaciones_feedback():
    """Nueva secci√≥n dedicada a an√°lisis de conversaciones por feedback"""
    st.markdown("## üîç An√°lisis de Conversaciones por Feedback")

    if st.session_state.datos is None:
        st.warning("‚ö†Ô∏è Primero debes conectar a la base de datos")
        return

    st.markdown('<div class="alerta-info">üìä Esta secci√≥n muestra conversaciones COMPLETAS basadas en el feedback de sus mensajes</div>', unsafe_allow_html=True)

    # Filtros espec√≠ficos para esta secci√≥n
    col1, col2, col3 = st.columns(3)

    with col1:
        try:
            fechas = pd.to_datetime(st.session_state.datos["createdAt"], errors='coerce').dropna()
            fecha_min = fechas.min().date() if not fechas.empty else datetime.now().date() - timedelta(days=30)
            fecha_max = fechas.max().date() if not fechas.empty else datetime.now().date()
        except:
            fecha_min = datetime.now().date() - timedelta(days=30)
            fecha_max = datetime.now().date()

        fecha_inicio = st.date_input("Fecha Inicio", fecha_min, key="fecha_inicio_feedback")
        fecha_fin = st.date_input("Fecha Fin", fecha_max, key="fecha_fin_feedback")

    with col2:
        tipos_feedback = []
        if "feedback" in st.session_state.datos.columns:
            opciones_feedback = list(st.session_state.datos["feedback"].dropna().unique()) + ["Sin feedback"]
            tipos_feedback = st.multiselect(
                "Tipos de Feedback a buscar",
                opciones_feedback,
                default=["positive", "negative"],
                key="tipos_feedback_especial"
            )

    with col3:
        st.markdown("<br>", unsafe_allow_html=True)
        analizar = st.button("üîç Buscar Conversaciones", type="primary", use_container_width=True)

    if analizar and tipos_feedback:
        with st.spinner("üîÑ Buscando conversaciones completas..."):
            try:
                df_conversaciones = obtener_conversaciones_por_feedback(
                    st.session_state.config_bd,
                    tipos_feedback,
                    fecha_inicio,
                    fecha_fin
                )

                if df_conversaciones.empty:
                    st.markdown('<div class="alerta-advertencia">‚ö†Ô∏è No se encontraron conversaciones con los filtros aplicados</div>', unsafe_allow_html=True)
                    return

                # Mostrar m√©tricas
                total_conversaciones = df_conversaciones["conversation_id"].nunique()
                total_mensajes = len(df_conversaciones)

                col1, col2, col3 = st.columns(3)
                with col1:
                    st.markdown(crear_metrica("Conversaciones Encontradas", f"{total_conversaciones:,}", "üó£Ô∏è", COLORES['primario']), unsafe_allow_html=True)
                with col2:
                    st.markdown(crear_metrica("Mensajes Totales", f"{total_mensajes:,}", "üí¨", COLORES['exito']), unsafe_allow_html=True)
                with col3:
                    usuarios = df_conversaciones["user_id"].nunique()
                    st.markdown(crear_metrica("Usuarios", f"{usuarios:,}", "üë•", COLORES['advertencia']), unsafe_allow_html=True)

                # Mostrar conversaciones con desplegables
                grupos = df_conversaciones.groupby("conversation_id")

                for conv_id, datos_conv in grupos:
                    # Resumen de la conversaci√≥n
                    titulo = datos_conv["conversation_title"].iloc[0] if pd.notna(datos_conv["conversation_title"].iloc[0]) else "Sin t√≠tulo"
                    usuario = datos_conv["user_id"].iloc[0]
                    fecha_inicio = datos_conv["createdAt"].min()
                    fecha_fin = datos_conv["createdAt"].max()
                    duracion = fecha_fin - fecha_inicio

                    # Contar feedbacks
                    feedback_counts = datos_conv["feedback"].fillna("Sin feedback").value_counts()
                    feedback_resumen = ", ".join([f"{k}: {v}" for k, v in feedback_counts.items()])

                    st.markdown(f"""
                    <div class="contenedor-conversacion">
                        <div class="encabezado-conversacion">
                            <div class="info-conversacion">
                                <div class="titulo-conversacion">üó£Ô∏è Conversaci√≥n {conv_id}</div>
                                <div class="meta-conversacion">üìã <strong>T√≠tulo:</strong> {titulo}</div>
                                <div class="meta-conversacion">üë§ <strong>Usuario:</strong> {usuario}</div>
                                <div class="meta-conversacion">üìÖ <strong>Duraci√≥n:</strong> {duracion}</div>
                                <div class="meta-conversacion">üìù <strong>Feedback:</strong> {feedback_resumen}</div>
                            </div>
                            <div class="etiqueta-conversacion">{len(datos_conv)} mensajes</div>
                        </div>
                    """, unsafe_allow_html=True)

                    # Desplegable con todos los mensajes
                    with st.expander(f"üëÅÔ∏è Ver conversaci√≥n completa ({len(datos_conv)} mensajes)", expanded=False):
                        for idx, (_, mensaje) in enumerate(datos_conv.iterrows(), 1):
                            rol = mensaje.get("role", "N/A").lower()
                            contenido = mensaje.get("content", "[Sin contenido]").strip()
                            timestamp = pd.to_datetime(mensaje.get("createdAt", "")).strftime("%Y-%m-%d %H:%M:%S")
                            feedback = mensaje.get("feedback", "Sin feedback")

                            clase_css = "mensaje-usuario" if rol == "user" else "mensaje-asistente" if rol == "assistant" else "mensaje-sistema"
                            icono = "üë§" if rol == "user" else "ü§ñ" if rol == "assistant" else "‚öôÔ∏è"

                            st.markdown(f"""
                            <div class="item-mensaje {clase_css}">
                                <div class="encabezado-mensaje">
                                    <div class="rol-mensaje">
                                        <span>{icono}</span>
                                        <span><strong>Mensaje #{idx} - {rol.title()}</strong></span>
                                        <span class="tiempo-mensaje">üïê {timestamp} | üìù Feedback: {feedback}</span>
                                    </div>
                                </div>
                                <div class="contenido-mensaje">{contenido}</div>
                            </div>
                            """, unsafe_allow_html=True)

                    st.markdown("</div>", unsafe_allow_html=True)
                    st.markdown("---")

            except Exception as e:
                st.error(f"‚ùå Error en el an√°lisis de conversaciones: {str(e)}")

















# ==================== AN√ÅLISIS SIN FEEDBACK COMPLETO (MEJORADO) ====================
def analizar_conversaciones_sin_feedback(df):
    st.markdown("## üîç An√°lisis Completo de Conversaciones Sin Feedback")

    if "feedback" not in df.columns:
        st.info("‚ÑπÔ∏è No hay datos de feedback disponibles")
        return

    sin_feedback = df[df["feedback"].isna()].copy()
    if sin_feedback.empty:
        st.markdown('<div class="alerta-exito">‚úÖ <strong>¬°Excelente!</strong> Todas las conversaciones tienen feedback.</div>', unsafe_allow_html=True)
        return

    total_sin_feedback = len(sin_feedback)
    conversaciones_afectadas = sin_feedback["conversation_id"].nunique() if "conversation_id" in sin_feedback.columns else 0
    usuarios_afectados = sin_feedback["user_id"].nunique() if "user_id" in sin_feedback.columns else 0

    st.markdown(f'<div class="alerta-info">üìã <strong>{total_sin_feedback:,} mensajes sin feedback</strong> en <strong>{conversaciones_afectadas:,} conversaciones</strong> de <strong>{usuarios_afectados:,} usuarios</strong></div>', unsafe_allow_html=True)

    grupos_conversacion = sin_feedback.groupby("conversation_id")
    stats_conversaciones = sin_feedback.groupby("conversation_id").agg({
        "id": "count", "user_id": "first", "conversation_title": "first",
        "createdAt": ["min", "max"], "role": lambda x: list(x.unique()),
        "type": lambda x: list(x.unique())
    }).round(2)

    stats_conversaciones.columns = ["cantidad_mensajes", "id_usuario", "titulo", "tiempo_inicio", "tiempo_fin", "roles", "tipos"]
    stats_conversaciones = stats_conversaciones.sort_values("cantidad_mensajes", ascending=False)

    total_conversaciones = len(stats_conversaciones)
    conversaciones_por_pagina = st.selectbox("Conversaciones por p√°gina:", [5, 10, 15, 20, 30], index=2)

    if total_conversaciones > conversaciones_por_pagina:
        total_paginas = (total_conversaciones + conversaciones_por_pagina - 1) // conversaciones_por_pagina
        pagina_actual = st.selectbox(f"P√°gina (Total: {total_paginas}):", range(1, total_paginas + 1))
        indice_inicio = (pagina_actual - 1) * conversaciones_por_pagina
        indice_fin = indice_inicio + conversaciones_por_pagina
        stats_pagina = stats_conversaciones.iloc[indice_inicio:indice_fin]
        st.markdown(f'<div class="alerta-info">üìÑ Mostrando conversaciones {indice_inicio + 1} a {min(indice_fin, total_conversaciones)} de {total_conversaciones}</div>', unsafe_allow_html=True)
    else:
        stats_pagina = stats_conversaciones

    for posicion, (id_conversacion, estadisticas) in enumerate(stats_pagina.iterrows(), 1):
        datos_conversacion = grupos_conversacion.get_group(id_conversacion)

        if estadisticas['cantidad_mensajes'] > 15:
            nivel_prioridad = "üî¥ Cr√≠tica"
            color_prioridad = COLORES['peligro']
        elif estadisticas['cantidad_mensajes'] > 8:
            nivel_prioridad = "üü° Alta"
            color_prioridad = COLORES['advertencia']
        else:
            nivel_prioridad = "üü¢ Media"
            color_prioridad = COLORES['exito']

        st.markdown(f"""
        <div class="contenedor-conversacion">
            <div class="encabezado-conversacion">
                <div class="info-conversacion">
                    <div class="titulo-conversacion">üó£Ô∏è Conversaci√≥n {id_conversacion}</div>
                    <div class="meta-conversacion">üìã <strong>T√≠tulo:</strong> {estadisticas['titulo'] if pd.notna(estadisticas['titulo']) else 'Sin t√≠tulo'}</div>
                    <div class="meta-conversacion">üë§ <strong>Usuario:</strong> {estadisticas['id_usuario']} | üé≠ <strong>Roles:</strong> {', '.join(estadisticas['roles'])}</div>
                    <div class="meta-conversacion">üìÖ <strong>Per√≠odo:</strong> {pd.to_datetime(estadisticas['tiempo_inicio']).strftime('%Y-%m-%d %H:%M')} ‚Üí {pd.to_datetime(estadisticas['tiempo_fin']).strftime('%Y-%m-%d %H:%M')}</div>
                    <div class="meta-conversacion">‚ö†Ô∏è <strong>Prioridad:</strong> <span style="color: {color_prioridad}; font-weight: bold;">{nivel_prioridad}</span></div>
                </div>
                <div class="etiqueta-conversacion">{estadisticas['cantidad_mensajes']} mensajes</div>
            </div>
        """, unsafe_allow_html=True)

        duracion = pd.to_datetime(estadisticas['tiempo_fin']) - pd.to_datetime(estadisticas['tiempo_inicio'])
        resumen_tipos = dict(datos_conversacion['type'].value_counts())
        promedio_diario = estadisticas['cantidad_mensajes'] / max(1, duracion.days) if duracion.days > 0 else estadisticas['cantidad_mensajes']

        st.markdown(f"""
        <div class="resumen-conversacion">
            <strong>üìä Resumen de la Conversaci√≥n</strong>
            <div class="cuadricula-resumen">
                <div class="item-resumen"><strong>‚è±Ô∏è Duraci√≥n:</strong><br>{duracion}</div>
                <div class="item-resumen"><strong>üìù Tipos √∫nicos:</strong><br>{len(resumen_tipos)}</div>
                <div class="item-resumen"><strong>üé≠ Roles:</strong><br>{len(estadisticas['roles'])}</div>
                <div class="item-resumen"><strong>üìä Promedio/d√≠a:</strong><br>{promedio_diario:.1f}</div>
            </div>
        </div>
        """, unsafe_allow_html=True)

        with st.expander(f"üëÅÔ∏è Ver los {estadisticas['cantidad_mensajes']} mensajes de la conversaci√≥n {id_conversacion}", expanded=False):
            mensajes_ordenados = datos_conversacion.sort_values("createdAt")

            for indice_mensaje, (_, mensaje) in enumerate(mensajes_ordenados.iterrows(), 1):
                rol = mensaje.get("role", "N/A").lower()
                contenido_raw = mensaje.get("content", "[Sin contenido]").strip()
                contenido = formatear_mensaje_tool(contenido_raw, mensaje.get("metadata"))
                timestamp = pd.to_datetime(mensaje.get("createdAt", "")).strftime("%Y-%m-%d %H:%M:%S")
                tipo_mensaje = mensaje.get("type", "general")
                id_usuario = mensaje.get("user_id", "desconocido")

                if rol == "user":
                    clase_css = "mensaje-usuario"
                    icono = "üë§"
                    nombre_rol = "Usuario"
                elif rol == "assistant":
                    clase_css = "mensaje-asistente"
                    icono = "ü§ñ"
                    nombre_rol = "Asistente"
                else:
                    clase_css = "mensaje-sistema"
                    icono = "‚öôÔ∏è"
                    nombre_rol = "Sistema"

                st.markdown(f"""
                <div class="item-mensaje {clase_css}">
                    <div class="encabezado-mensaje">
                        <div class="rol-mensaje">
                            <span>{icono}</span>
                            <span><strong>Mensaje #{indice_mensaje} - {nombre_rol}</strong></span>
                            <span style="font-size:0.8rem;color:#6c757d;">({tipo_mensaje})</span>
                        </div>
                        <div class="tiempo-mensaje">üïê {timestamp} | üë§ {id_usuario}</div>
                    </div>
                    <div class="contenido-mensaje">
                        <strong>üí¨ Contenido:</strong><br>
                        {contenido[:1000]}{'...' if len(contenido) > 1000 else ''}
                    </div>
                """, unsafe_allow_html=True)

                campos_tecnicos = {
                    "question": "‚ùì Pregunta", "expected_response": "üìå Respuesta Esperada",
                    "expected_documents": "üìé Documentos Esperados", "function_call": "‚öôÔ∏è Funci√≥n",
                    "llm_filters": "üîç Filtros LLM", "source_documents": "üìö Documentos",
                    "feedback_content": "üí≠ Contenido Feedback"
                }

                tiene_info_tecnica = False
                html_tecnico = '<div class="info-tecnica-mensaje"><strong>üîß Informaci√≥n T√©cnica:</strong><br>'

                for campo, etiqueta in campos_tecnicos.items():
                    valor_campo = mensaje.get(campo)
                    if valor_campo and str(valor_campo).strip() not in ['', 'nan', 'None', 'null']:
                        tiene_info_tecnica = True
                        valor_mostrar = str(valor_campo)[:400] + ('...' if len(str(valor_campo)) > 400 else '')
                        html_tecnico += f'<div class="campo-tecnico"><span class="etiqueta-campo">{etiqueta}:</span><span class="valor-campo">{valor_mostrar}</span></div>'

                html_tecnico += '</div>'
                if tiene_info_tecnica:
                    st.markdown(html_tecnico, unsafe_allow_html=True)

                st.markdown("</div>", unsafe_allow_html=True)

        st.markdown("</div>", unsafe_allow_html=True)
        st.markdown("---")

# ==================== FORMATEADOR UNIVERSAL PARA MENSAJES TOOL ====================
def formatear_mensaje_tool(contenido, metadata=None):
    # [El c√≥digo del formateador permanece igual...]
    # (Se mantiene el mismo c√≥digo original para mantener la respuesta corta)
    return str(contenido)  # Placeholder - usa el c√≥digo original completo aqu√≠

# ==================== MEN√ö LATERAL CON NUEVA OPCI√ìN ====================
def mostrar_menu_lateral():
    with st.sidebar:
        st.markdown("### üéØ Modo de An√°lisis")
        modo_analisis = st.radio(
            "Selecciona el tipo de an√°lisis:",
            ["An√°lisis General", "An√°lisis de Conversaciones por Feedback"],
            index=0
        )
        return modo_analisis

# ==================== APLICACI√ìN PRINCIPAL ====================
def main():
    aplicar_estilos()
    
    # Encabezado din√°mico sin mostrar usuario
    st.markdown(f"""
    <div class="encabezado-principal">
        <h1 style="margin: 0; font-size: 2.5rem;">üìä RAN AVAD Analytics Dashboard</h1>
        <p style="margin: 0.5rem 0 0 0; opacity: 0.9; font-size: 1.2rem;">
            M√©tricas completas - WebApp
        </p>
        <p style="margin: 0.3rem 0 0 0; font-size: 0.9rem; opacity: 0.8;">
            üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Conexi√≥n BD
    usuario, contrase√±a, servidor, base_datos, conectar = mostrar_conexion()

    if conectar:
        with st.spinner("üîÑ Conectando y cargando datos completos..."):
            try:
                tiempo_inicio = datetime.now()
                datos_completos = cargar_datos(usuario, contrase√±a, servidor, base_datos)
                tiempo_carga = (datetime.now() - tiempo_inicio).total_seconds()

                st.session_state.datos = datos_completos
                st.session_state.config_bd = {"user": usuario, "password": contrase√±a, "host": servidor, "database": base_datos}
                st.session_state.bd_conectada = True

                st.markdown(f'<div class="alerta-exito">‚úÖ <strong>Conexi√≥n exitosa!</strong> Cargados {len(datos_completos):,} registros en {tiempo_carga:.2f}s</div>', unsafe_allow_html=True)

            except Exception as e:
                st.markdown(f'<div class="alerta-advertencia">‚ùå <strong>Error:</strong> {str(e)}</div>', unsafe_allow_html=True)
                st.session_state.bd_conectada = False

    # NUEVO MEN√ö LATERAL
    modo_analisis = mostrar_menu_lateral()

    # L√≥gica seg√∫n el modo seleccionado
    if st.session_state.datos is not None:
        if modo_analisis == "An√°lisis General":
            # [El resto del c√≥digo original del an√°lisis general permanece igual...]
            st.markdown("### üìä An√°lisis General")
            # Incluye el c√≥digo original completo aqu√≠
            
        else:  # "An√°lisis de Conversaciones por Feedback"
            mostrar_analisis_conversaciones_feedback()

    # Panel estado sin mostrar usuarios
    with st.sidebar:
        st.markdown("---")
        st.markdown("### üìä Estado del Sistema")
        items_estado = [
            ("üïê Hora", datetime.now().strftime('%H:%M:%S')),
            ("üîó BD", "‚úÖ Conectada" if st.session_state.bd_conectada else "‚ùå Desconectada"),
            ("üìä Datos", f"‚úÖ {len(st.session_state.datos):,}" if st.session_state.datos is not None else "‚ùå Sin datos"),
            ("üìã Resultados", f"‚úÖ {len(st.session_state.resultados):,}" if st.session_state.resultados is not None else "‚ùå Sin an√°lisis")
        ]

        for etiqueta, valor in items_estado:
            st.markdown(f"**{etiqueta}:** {valor}")

        if st.button("üîÑ Actualizar Cache"):
            st.cache_data.clear()
            st.success("‚úÖ Cache actualizada")
            st.rerun()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        st.error(f"‚ùå **Error cr√≠tico:** {str(e)}")
        st.markdown("**üîß Soluci√≥n:** Recarga la p√°gina (F5)")
        if st.button("üÜò Reiniciar"):
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.cache_data.clear()
            st.rerun()


