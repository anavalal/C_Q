Mensaje #5 - Tool
üïê 2025-06-09 13:40:50 | üìù Feedback: None
{"citations": [{"content": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A40%3A50Z&sp=r&sv=2024-05-04&sr=c&sig=HMz0lwUVtjve4Ft0wZdFL/6iStr7VDoSVQtd%2BIwoTA8%3D)\n\n\nmediante un Indicador que permita el filtrado posterior:\nFiltrado de contadores por Partici\u00f3n:\nEl indicador \u201c_PartitionIdX\u201d va a ser el que se utilice para generar los contadores Flex por partici\u00f3n.\nPor ejemplo, para el contador gen\u00e9rico pmEbsMacRBSymUtilDlPartitionDistr, de tipo Flex, se definir\u00e1n los siguientes contadores de acuerdo con la configuraci\u00f3n de la tabla del apartado anterior:\n\u00b7 pmEbsMacRBSymUtilDlPartitionDistr_PartitionId1: partici\u00f3n asociada al tr\u00e1fico de la partici\u00f3n \u201cPrioritized\u201d, correspondiente con el tr\u00e1fico de las slices 1-199, 1-201, 1-301 y 1-351.\n\u00b7 pmEbsMacRBSymUtilDlPartitionDistr_PartitionId10: partici\u00f3n asociada al tr\u00e1fico de las slices 1-600 y 1-203, del servicio de emergencias. La 1-203, s\u00f3lo definida en Extremadura.\nFiltrado de contadores por Slice (S-NSSAI): \nSe utilizar\u00e1 el indicador \u201c_sstXsdY\u201d en el caso de los contadores flexibles.\nPor ejemplo, para el contador gen\u00e9rico pmEbsnMacTimeDlDrb, se definir\u00e1n los siguientes contadores de acuerdo con la tabla, para todas las slices:\n\u00b7 pmEbsnMacTimeDlDrb_sst1sd1\n\u00b7 pmEbsnMacTimeDlDrb_sst1sd199\n\u00b7 pmEbsnMacTimeDlDrb_sst1sd200\n\u00b7 [\u2026]\n\n\nKPIs y Contadores por slice\nLos KPIs para evaluar las slices se sean a partir de contadores EBS de tipo Flexible. Como se ha visto, estos incorporan un filtro S-NSSAI que se desagrega en los campos sstX y sdY donde X e Y identificar\u00e1n las distintas slices.\nThroughput DL y UL\nSe basa en contadores de NRCellDU:\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tAverage DL MAC UE Throughput [kbps]\n\t64* pmEbsnMacVolDlDrb _sstXsdY / pmEbsnMacTimeDlDrb _sstXsdY\n\tThroughput promediado para SA por Slice (S-NSSAI; sstXsdY), en DL\n\n\tAverage UL MAC UE Throughput [kbps]\n\t64* pmEbsnMacVolUlResUe_sstXsdY / pmEbsnMacTimeUlResUe_sstXsdY\n\tThroughput promediado para SA por Slice (S-NSSAI; sstXsdY), en UL\n\n\n\n\nVolumen de datos en DL y UL\nSe basa en contadores de NRCellDU:\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tAverage DL MAC UE Vol [Bytes]\n\t pmEbsnMacVolDlDrb _sstXsdY", "id": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "chunk_id": "3", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "filepath": "NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx", "url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A40%3A50Z&sp=r&sv=2024-05-04&sr=c&sig=HMz0lwUVtjve4Ft0wZdFL/6iStr7VDoSVQtd%2BIwoTA8%3D)", "metadata": {"offset": null, "source": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "markdown_url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A40%3A50Z&sp=r&sv=2024-05-04&sr=c&sig=HMz0lwUVtjve4Ft0wZdFL/6iStr7VDoSVQtd%2BIwoTA8%3D)", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "original_url": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "chunk": null, "key": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "filename": "NIR-952_Ericsson%20Estadisticas_por_slice_v2"}}], "intent": "explica como es el filtrado de contadores por Slice en Ericsson"}
ü§ñ
Mensaje #6 - Assistant
üïê 2025-06-09 13:40:50 | üìù Feedback: None
El filtrado de contadores por slice en Ericsson se realiza utilizando el indicador "sstXsdY" en los contadores flexibles. Este indicador permite desagregar los contadores en los campos `sstX` y `sdY`, donde `X` e `Y` identifican las distintas slices. Por ejemplo, para el contador gen√©rico `pmEbsnMacTimeDlDrb`, se definen contadores espec√≠ficos para cada slice, como `pmEbsnMacTimeDlDrb_sst1sd1`, `pmEbsnMacTimeDlDrb_sst1sd199`, `pmEbsnMacTimeDlDrb_sst1sd200`, entre otros [doc1].
üë§
Mensaje #7 - User
üïê 2025-06-09 13:42:18 | üìù Feedback: None
cuales son los KPIS Y CONTADORES POR SLICE en Ericsson?
‚öôÔ∏è
Mensaje #8 - Tool
üïê 2025-06-09 13:42:18 | üìù Feedback: None
{"citations": [{"content": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)\n\n\nmediante un Indicador que permita el filtrado posterior:\nFiltrado de contadores por Partici\u00f3n:\nEl indicador \u201c_PartitionIdX\u201d va a ser el que se utilice para generar los contadores Flex por partici\u00f3n.\nPor ejemplo, para el contador gen\u00e9rico pmEbsMacRBSymUtilDlPartitionDistr, de tipo Flex, se definir\u00e1n los siguientes contadores de acuerdo con la configuraci\u00f3n de la tabla del apartado anterior:\n\u00b7 pmEbsMacRBSymUtilDlPartitionDistr_PartitionId1: partici\u00f3n asociada al tr\u00e1fico de la partici\u00f3n \u201cPrioritized\u201d, correspondiente con el tr\u00e1fico de las slices 1-199, 1-201, 1-301 y 1-351.\n\u00b7 pmEbsMacRBSymUtilDlPartitionDistr_PartitionId10: partici\u00f3n asociada al tr\u00e1fico de las slices 1-600 y 1-203, del servicio de emergencias. La 1-203, s\u00f3lo definida en Extremadura.\nFiltrado de contadores por Slice (S-NSSAI): \nSe utilizar\u00e1 el indicador \u201c_sstXsdY\u201d en el caso de los contadores flexibles.\nPor ejemplo, para el contador gen\u00e9rico pmEbsnMacTimeDlDrb, se definir\u00e1n los siguientes contadores de acuerdo con la tabla, para todas las slices:\n\u00b7 pmEbsnMacTimeDlDrb_sst1sd1\n\u00b7 pmEbsnMacTimeDlDrb_sst1sd199\n\u00b7 pmEbsnMacTimeDlDrb_sst1sd200\n\u00b7 [\u2026]\n\n\nKPIs y Contadores por slice\nLos KPIs para evaluar las slices se sean a partir de contadores EBS de tipo Flexible. Como se ha visto, estos incorporan un filtro S-NSSAI que se desagrega en los campos sstX y sdY donde X e Y identificar\u00e1n las distintas slices.\nThroughput DL y UL\nSe basa en contadores de NRCellDU:\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tAverage DL MAC UE Throughput [kbps]\n\t64* pmEbsnMacVolDlDrb _sstXsdY / pmEbsnMacTimeDlDrb _sstXsdY\n\tThroughput promediado para SA por Slice (S-NSSAI; sstXsdY), en DL\n\n\tAverage UL MAC UE Throughput [kbps]\n\t64* pmEbsnMacVolUlResUe_sstXsdY / pmEbsnMacTimeUlResUe_sstXsdY\n\tThroughput promediado para SA por Slice (S-NSSAI; sstXsdY), en UL\n\n\n\n\nVolumen de datos en DL y UL\nSe basa en contadores de NRCellDU:\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tAverage DL MAC UE Vol [Bytes]\n\t pmEbsnMacVolDlDrb _sstXsdY", "id": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "chunk_id": "3", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "filepath": "NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx", "url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)", "metadata": {"offset": null, "source": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "markdown_url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "original_url": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "chunk": null, "key": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "filename": "NIR-952_Ericsson%20Estadisticas_por_slice_v2"}}, {"content": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)\n\n\nmediante un Indicador que permita el filtrado posterior:\nFiltrado de contadores por Partici\u00f3n:\nEl indicador \u201c_PartitionIdX\u201d va a ser el que se utilice para generar los contadores Flex por partici\u00f3n.\nPor ejemplo, para el contador gen\u00e9rico pmEbsMacRBSymUtilDlPartitionDistr, de tipo Flex, se definir\u00e1n los siguientes contadores de acuerdo con la configuraci\u00f3n de la tabla del apartado anterior:\n\u00b7 pmEbsMacRBSymUtilDlPartitionDistr_PartitionId1: partici\u00f3n asociada al tr\u00e1fico de la partici\u00f3n \u201cPrioritized\u201d, correspondiente con el tr\u00e1fico de las slices 1-199, 1-201, 1-301 y 1-351.\n\u00b7 pmEbsMacRBSymUtilDlPartitionDistr_PartitionId10: partici\u00f3n asociada al tr\u00e1fico de las slices 1-600 y 1-203, del servicio de emergencias. La 1-203, s\u00f3lo definida en Extremadura.\nFiltrado de contadores por Slice (S-NSSAI): \nSe utilizar\u00e1 el indicador \u201c_sstXsdY\u201d en el caso de los contadores flexibles.\nPor ejemplo, para el contador gen\u00e9rico pmEbsnMacTimeDlDrb, se definir\u00e1n los siguientes contadores de acuerdo con la tabla, para todas las slices:\n\u00b7 pmEbsnMacTimeDlDrb_sst1sd1\n\u00b7 pmEbsnMacTimeDlDrb_sst1sd199\n\u00b7 pmEbsnMacTimeDlDrb_sst1sd200\n\u00b7 [\u2026]\n\n\nKPIs y Contadores por slice\nLos KPIs para evaluar las slices se sean a partir de contadores EBS de tipo Flexible. Como se ha visto, estos incorporan un filtro S-NSSAI que se desagrega en los campos sstX y sdY donde X e Y identificar\u00e1n las distintas slices.\nThroughput DL y UL\nSe basa en contadores de NRCellDU:\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tAverage DL MAC UE Throughput [kbps]\n\t64* pmEbsnMacVolDlDrb _sstXsdY / pmEbsnMacTimeDlDrb _sstXsdY\n\tThroughput promediado para SA por Slice (S-NSSAI; sstXsdY), en DL\n\n\tAverage UL MAC UE Throughput [kbps]\n\t64* pmEbsnMacVolUlResUe_sstXsdY / pmEbsnMacTimeUlResUe_sstXsdY\n\tThroughput promediado para SA por Slice (S-NSSAI; sstXsdY), en UL\n\n\n\n\nVolumen de datos en DL y UL\nSe basa en contadores de NRCellDU:\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tAverage DL MAC UE Vol [Bytes]\n\t pmEbsnMacVolDlDrb _sstXsdY", "id": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "chunk_id": "3", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "filepath": "NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx", "url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)", "metadata": {"offset": null, "source": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "markdown_url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "original_url": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "chunk": null, "key": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "filename": "NIR-952_Ericsson%20Estadisticas_por_slice_v2"}}, {"content": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)\n\n\nSlice (S-NSSAI; sstXsdY), en UL\n\n\n\n\nVolumen de datos en DL y UL\nSe basa en contadores de NRCellDU:\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tAverage DL MAC UE Vol [Bytes]\n\t pmEbsnMacVolDlDrb _sstXsdY \n\tVolumen promediado para SA por Slice (S-NSSAI; sstXsdY), en DL\n\n\tAverage UL MAC UE Vol [Bytes]\n\tpmEbsnMacVolUlResUe_sstXsdY\n\tVolumen promediado para SA por Slice (S-NSSAI; sstXsdY), en UL\n\n\n\n\n\n\n\nN\u00ba de DRBs m\u00e1ximo y agregado\nSe basa en contadores de NRCellCU:\n\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tN\u00famero medio de DRBs\n\tpmEbsDrbLevelSnssaiSumSa_sstXsdY/180\n\n\tCada 5 seg. se toma una muestra del n\u00ba de DRBs establecidas en la celda por S-NSSAI (sstXsdY) y se van acumulando las muestras hasta completar un ROP (900 seg = 180 muestras)\n\n\tN\u00famero m\u00e1ximo de DRBs\n\tpmEbsDrbLevelSnssaiMaxSa_sstXsdY\n \n\tCada 5 seg. se toma una muestra del n\u00ba de DRBs establecidas en la celda por S-NSSAI (sstXsdY) y al t\u00e9rmino del ROP, se reporta el valor de pico\n\n\nContadores REFERIDOS A LAS PARTICIONES\nEn Ericsson existen contadores que nos proporcionan informaci\u00f3n sobre el uso de recursos por tipo de tr\u00e1fico, referido a las particiones. \nLos que terminan en \u201c_Distr\u201d son de tipo vector. En este caso, cada contador es un vector de 20 posiciones: [0], [1], \u2026 ,[19].\n\tCada posici\u00f3n del vector corresponde a un rango de utilizaci\u00f3n de RBSym, respecto al total de RBSym DL/UL disponibles:\no\t[0]: [0-5] %\no\t[1]: [6-10] %\n\u2026\no\t[19]:[96-100] %\nPara cada contador: Cada segundo se obtiene una muestra del porcentaje medio de utilizaci\u00f3n de RBSym UL/DL respecto al total de RBSym UL/DL disponibles en la celda y cada segundo se incrementa la posici\u00f3n del contador a cuyo rango corresponde el valor de la muestra calculada (%).\nEn t\u00e9rminos de observabilidad, se diferencian los siguientes tipos de tr\u00e1fico:\n\tTipo de tr\u00e1fico\n\tContadores EBS\n\n\tTr\u00e1fico definido por partici\u00f3n\n\tpmEBSMacRBSymUtilDlPartitionDistr_PartitionIdX\npmEBSMacRBSymUtilUlPartitionDistr_PartitionIdX", "id": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "chunk_id": "4", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "filepath": "NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx", "url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)", "metadata": {"offset": null, "source": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "markdown_url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "original_url": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "chunk": null, "key": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "filename": "NIR-952_Ericsson%20Estadisticas_por_slice_v2"}}, {"content": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)\n\n\nSlice (S-NSSAI; sstXsdY), en UL\n\n\n\n\nVolumen de datos en DL y UL\nSe basa en contadores de NRCellDU:\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tAverage DL MAC UE Vol [Bytes]\n\t pmEbsnMacVolDlDrb _sstXsdY \n\tVolumen promediado para SA por Slice (S-NSSAI; sstXsdY), en DL\n\n\tAverage UL MAC UE Vol [Bytes]\n\tpmEbsnMacVolUlResUe_sstXsdY\n\tVolumen promediado para SA por Slice (S-NSSAI; sstXsdY), en UL\n\n\n\n\n\n\n\nN\u00ba de DRBs m\u00e1ximo y agregado\nSe basa en contadores de NRCellCU:\n\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tN\u00famero medio de DRBs\n\tpmEbsDrbLevelSnssaiSumSa_sstXsdY/180\n\n\tCada 5 seg. se toma una muestra del n\u00ba de DRBs establecidas en la celda por S-NSSAI (sstXsdY) y se van acumulando las muestras hasta completar un ROP (900 seg = 180 muestras)\n\n\tN\u00famero m\u00e1ximo de DRBs\n\tpmEbsDrbLevelSnssaiMaxSa_sstXsdY\n \n\tCada 5 seg. se toma una muestra del n\u00ba de DRBs establecidas en la celda por S-NSSAI (sstXsdY) y al t\u00e9rmino del ROP, se reporta el valor de pico\n\n\nContadores REFERIDOS A LAS PARTICIONES\nEn Ericsson existen contadores que nos proporcionan informaci\u00f3n sobre el uso de recursos por tipo de tr\u00e1fico, referido a las particiones. \nLos que terminan en \u201c_Distr\u201d son de tipo vector. En este caso, cada contador es un vector de 20 posiciones: [0], [1], \u2026 ,[19].\n\tCada posici\u00f3n del vector corresponde a un rango de utilizaci\u00f3n de RBSym, respecto al total de RBSym DL/UL disponibles:\no\t[0]: [0-5] %\no\t[1]: [6-10] %\n\u2026\no\t[19]:[96-100] %\nPara cada contador: Cada segundo se obtiene una muestra del porcentaje medio de utilizaci\u00f3n de RBSym UL/DL respecto al total de RBSym UL/DL disponibles en la celda y cada segundo se incrementa la posici\u00f3n del contador a cuyo rango corresponde el valor de la muestra calculada (%).\nEn t\u00e9rminos de observabilidad, se diferencian los siguientes tipos de tr\u00e1fico:\n\tTipo de tr\u00e1fico\n\tContadores EBS\n\n\tTr\u00e1fico definido por partici\u00f3n\n\tpmEBSMacRBSymUtilDlPartitionDistr_PartitionIdX\npmEBSMacRBSymUtilUlPartitionDistr_PartitionIdX", "id": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "chunk_id": "4", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "filepath": "NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx", "url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)", "metadata": {"offset": null, "source": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "markdown_url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "original_url": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "chunk": null, "key": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "filename": "NIR-952_Ericsson%20Estadisticas_por_slice_v2"}}, {"content": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)\n\n\nSlice (S-NSSAI; sstXsdY), en UL\n\n\n\n\nVolumen de datos en DL y UL\nSe basa en contadores de NRCellDU:\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tAverage DL MAC UE Vol [Bytes]\n\t pmEbsnMacVolDlDrb _sstXsdY \n\tVolumen promediado para SA por Slice (S-NSSAI; sstXsdY), en DL\n\n\tAverage UL MAC UE Vol [Bytes]\n\tpmEbsnMacVolUlResUe_sstXsdY\n\tVolumen promediado para SA por Slice (S-NSSAI; sstXsdY), en UL\n\n\n\n\n\n\n\nN\u00ba de DRBs m\u00e1ximo y agregado\nSe basa en contadores de NRCellCU:\n\n\n\tKPI\n\tContador/f\u00f3rmula\n\tDefinici\u00f3n\n\n\tN\u00famero medio de DRBs\n\tpmEbsDrbLevelSnssaiSumSa_sstXsdY/180\n\n\tCada 5 seg. se toma una muestra del n\u00ba de DRBs establecidas en la celda por S-NSSAI (sstXsdY) y se van acumulando las muestras hasta completar un ROP (900 seg = 180 muestras)\n\n\tN\u00famero m\u00e1ximo de DRBs\n\tpmEbsDrbLevelSnssaiMaxSa_sstXsdY\n \n\tCada 5 seg. se toma una muestra del n\u00ba de DRBs establecidas en la celda por S-NSSAI (sstXsdY) y al t\u00e9rmino del ROP, se reporta el valor de pico\n\n\nContadores REFERIDOS A LAS PARTICIONES\nEn Ericsson existen contadores que nos proporcionan informaci\u00f3n sobre el uso de recursos por tipo de tr\u00e1fico, referido a las particiones. \nLos que terminan en \u201c_Distr\u201d son de tipo vector. En este caso, cada contador es un vector de 20 posiciones: [0], [1], \u2026 ,[19].\n\tCada posici\u00f3n del vector corresponde a un rango de utilizaci\u00f3n de RBSym, respecto al total de RBSym DL/UL disponibles:\no\t[0]: [0-5] %\no\t[1]: [6-10] %\n\u2026\no\t[19]:[96-100] %\nPara cada contador: Cada segundo se obtiene una muestra del porcentaje medio de utilizaci\u00f3n de RBSym UL/DL respecto al total de RBSym UL/DL disponibles en la celda y cada segundo se incrementa la posici\u00f3n del contador a cuyo rango corresponde el valor de la muestra calculada (%).\nEn t\u00e9rminos de observabilidad, se diferencian los siguientes tipos de tr\u00e1fico:\n\tTipo de tr\u00e1fico\n\tContadores EBS\n\n\tTr\u00e1fico definido por partici\u00f3n\n\tpmEBSMacRBSymUtilDlPartitionDistr_PartitionIdX\npmEBSMacRBSymUtilUlPartitionDistr_PartitionIdX", "id": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "chunk_id": "4", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "filepath": "NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx", "url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)", "metadata": {"offset": null, "source": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "markdown_url": "[NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx](https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%2520y%2520Planificacion/NIR/NIR-952_Ericsson%2520Estadisticas_por_slice_v2.1.docx?se=2030-06-08T13%3A42%3A18Z&sp=r&sv=2024-05-04&sr=c&sig=lICeTJI/iZdpJx9asqYBFMffOnFUGG7KCqBfKsLq5PM%3D)", "title": "NIR-952_Ericsson Estadisticas_por_slice_v2.1.docx", "original_url": "https://teasa02seuwepcteradlake.blob.core.windows.net/documentacion/indexar/Interna/AccesoMovil_NucleoRed/Optimizacion%20y%20Planificacion/NIR/NIR-952_Ericsson%20Estadisticas_por_slice_v2.1.docx_SAS_TOKEN_PLACEHOLDER_", "chunk": null, "key": "aHR0cHM6Ly90ZWFzYTAyc2V1d2VwY3RlcmFkbGFrZS5ibG9iLmNvcmUud2luZG93cy5uZXQvZG9jdW1lbnRhY2lvbi9pbmRleGFyL0ludGVybmEvQWNjZXNvTW92aWxfTnVjbGVvUmVkL09wdGltaXphY2lvbiUyMHklMjBQbGFuaWZpY2FjaW9uL05JUi9OSVItOTUyX0VyaWNzc29uJTIwRXN0YWRpc3RpY2FzX3Bvcl9zbGljZV92Mi4xLmRvY3g1", "filename": "NIR-952_Ericsson%20Estadisticas_por_slice_v2"}}], "intent": "cuales son los KPIS Y CONTADORES POR SLICE en Ericsson?"}






















# ==================== NUEVO APARTADO: AN√ÅLISIS DE CONVERSACIONES POR FEEDBACK ====================
@st.cache_data(ttl=300, show_spinner=False)
def obtener_conversaciones_por_feedback(_config_bd, tipos_feedback, fecha_inicio, fecha_fin):
    """Obtiene conversaciones COMPLETAS que tienen al menos un mensaje con el feedback especificado"""
    async def consulta():
        client = PostgresConversationClient(**_config_bd)
        await client.connect()
        
        # Primero, encontrar las conversaciones que tienen el feedback especificado
        condiciones = []
        parametros = [f"{fecha_inicio} 00:00:00+00:00", f"{fecha_fin} 23:59:59+00:00"]
        
        base_query = """
        SELECT DISTINCT m.conversation_id
        FROM messages m
        WHERE m."createdAt" BETWEEN $1 AND $2
        """
        
        if tipos_feedback and 'Sin feedback' not in tipos_feedback:
            marcadores = ', '.join([f'${i+3}' for i in range(len(tipos_feedback))])
            base_query += f" AND m.feedback IN ({marcadores})"
            parametros.extend(tipos_feedback)
        elif 'Sin feedback' in tipos_feedback and len(tipos_feedback) > 1:
            tipos_limpios = [t for t in tipos_feedback if t != 'Sin feedback']
            if tipos_limpios:
                marcadores = ', '.join([f'${i+3}' for i in range(len(tipos_limpios))])
                base_query += f" AND (m.feedback IN ({marcadores}) OR m.feedback IS NULL)"
                parametros.extend(tipos_limpios)
        elif 'Sin feedback' in tipos_feedback:
            base_query += " AND m.feedback IS NULL"
        
        # Obtener todas las conversaciones que coinciden
        conversaciones_query = f"""
        SELECT m.*, c.title AS conversation_title, c.type AS conversation_type
        FROM messages m
        LEFT JOIN conversations c ON m.conversation_id = c.conversation_id
        WHERE m.conversation_id IN ({base_query})
        AND m."createdAt" BETWEEN $1 AND $2
        ORDER BY m.conversation_id, m."createdAt"
        """
        
        resultados = await client.conn.fetch(conversaciones_query, *parametros)
        await client.close()
        df = pd.DataFrame([dict(fila) for fila in resultados])
        if not df.empty and "createdAt" in df.columns:
            df["createdAt"] = normalizar_fechas(df["createdAt"])
        return df
    return ejecutar_async(consulta())

def mostrar_analisis_conversaciones_feedback():
    """Nueva secci√≥n dedicada a an√°lisis de conversaciones por feedback"""
    st.markdown("## üîç An√°lisis de Conversaciones por Feedback")
    
    if st.session_state.datos is None:
        st.warning("‚ö†Ô∏è Primero debes conectar a la base de datos")
        return
    
    st.markdown('<div class="alerta-info">üìä Esta secci√≥n muestra conversaciones COMPLETAS basadas en el feedback de sus mensajes</div>', unsafe_allow_html=True)
    
    # Filtros espec√≠ficos para esta secci√≥n
    col1, col2, col3 = st.columns(3)
    
    with col1:
        try:
            fechas = pd.to_datetime(st.session_state.datos["createdAt"], errors='coerce').dropna()
            fecha_min = fechas.min().date() if not fechas.empty else datetime.now().date() - timedelta(days=30)
            fecha_max = fechas.max().date() if not fechas.empty else datetime.now().date()
        except:
            fecha_min = datetime.now().date() - timedelta(days=30)
            fecha_max = datetime.now().date()
        
        fecha_inicio = st.date_input("Fecha Inicio", fecha_min, key="fecha_inicio_feedback")
        fecha_fin = st.date_input("Fecha Fin", fecha_max, key="fecha_fin_feedback")
    
    with col2:
        tipos_feedback = []
        if "feedback" in st.session_state.datos.columns:
            opciones_feedback = list(st.session_state.datos["feedback"].dropna().unique()) + ["Sin feedback"]
            tipos_feedback = st.multiselect(
                "Tipos de Feedback a buscar",
                opciones_feedback,
                default=["positive", "negative"],
                key="tipos_feedback_especial"
            )
    
    with col3:
        st.markdown("<br>", unsafe_allow_html=True)
        analizar = st.button("üîç Buscar Conversaciones", type="primary", use_container_width=True)
    
    if analizar and tipos_feedback:
        with st.spinner("üîÑ Buscando conversaciones completas..."):
            try:
                df_conversaciones = obtener_conversaciones_por_feedback(
                    st.session_state.config_bd, 
                    tipos_feedback, 
                    fecha_inicio, 
                    fecha_fin
                )
                
                if df_conversaciones.empty:
                    st.markdown('<div class="alerta-advertencia">‚ö†Ô∏è No se encontraron conversaciones con los filtros aplicados</div>', unsafe_allow_html=True)
                    return
                
                # Mostrar m√©tricas
                total_conversaciones = df_conversaciones["conversation_id"].nunique()
                total_mensajes = len(df_conversaciones)
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.markdown(crear_metrica("Conversaciones Encontradas", f"{total_conversaciones:,}", "üó£Ô∏è", COLORES['primario']), unsafe_allow_html=True)
                with col2:
                    st.markdown(crear_metrica("Mensajes Totales", f"{total_mensajes:,}", "üí¨", COLORES['exito']), unsafe_allow_html=True)
                with col3:
                    usuarios = df_conversaciones["user_id"].nunique()
                    st.markdown(crear_metrica("Usuarios", f"{usuarios:,}", "üë•", COLORES['advertencia']), unsafe_allow_html=True)
                
                # Mostrar conversaciones con desplegables
                grupos = df_conversaciones.groupby("conversation_id")
                
                for conv_id, datos_conv in grupos:
                    # Resumen de la conversaci√≥n
                    titulo = datos_conv["conversation_title"].iloc[0] if pd.notna(datos_conv["conversation_title"].iloc[0]) else "Sin t√≠tulo"
                    usuario = datos_conv["user_id"].iloc[0]
                    fecha_inicio = datos_conv["createdAt"].min()
                    fecha_fin = datos_conv["createdAt"].max()
                    duracion = fecha_fin - fecha_inicio
                    
                    # Contar feedbacks
                    feedback_counts = datos_conv["feedback"].fillna("Sin feedback").value_counts()
                    feedback_resumen = ", ".join([f"{k}: {v}" for k, v in feedback_counts.items()])
                    
                    st.markdown(f"""
                    <div class="contenedor-conversacion">
                        <div class="encabezado-conversacion">
                            <div class="info-conversacion">
                                <div class="titulo-conversacion">üó£Ô∏è Conversaci√≥n {conv_id}</div>
                                <div class="meta-conversacion">üìã <strong>T√≠tulo:</strong> {titulo}</div>
                                <div class="meta-conversacion">üë§ <strong>Usuario:</strong> {usuario}</div>
                                <div class="meta-conversacion">üìÖ <strong>Duraci√≥n:</strong> {duracion}</div>
                                <div class="meta-conversacion">üìù <strong>Feedback:</strong> {feedback_resumen}</div>
                            </div>
                            <div class="etiqueta-conversacion">{len(datos_conv)} mensajes</div>
                        </div>
                    """, unsafe_allow_html=True)
                    
                    # Desplegable con todos los mensajes
                    with st.expander(f"üëÅÔ∏è Ver conversaci√≥n completa ({len(datos_conv)} mensajes)", expanded=False):
                        for idx, (_, mensaje) in enumerate(datos_conv.iterrows(), 1):
                            rol = mensaje.get("role", "N/A").lower()
                            contenido = mensaje.get("content", "[Sin contenido]").strip()
                            timestamp = pd.to_datetime(mensaje.get("createdAt", "")).strftime("%Y-%m-%d %H:%M:%S")
                            feedback = mensaje.get("feedback", "Sin feedback")
                            
                            clase_css = "mensaje-usuario" if rol == "user" else "mensaje-asistente" if rol == "assistant" else "mensaje-sistema"
                            icono = "üë§" if rol == "user" else "ü§ñ" if rol == "assistant" else "‚öôÔ∏è"
                            
                            st.markdown(f"""
                            <div class="item-mensaje {clase_css}">
                                <div class="encabezado-mensaje">
                                    <div class="rol-mensaje">
                                        <span>{icono}</span>
                                        <span><strong>Mensaje #{idx} - {rol.title()}</strong></span>
                                        <span class="tiempo-mensaje">üïê {timestamp} | üìù Feedback: {feedback}</span>
                                    </div>
                                </div>
                                <div class="contenido-mensaje">{contenido}</div>
                            </div>
                            """, unsafe_allow_html=True)
                    
                    st.markdown("</div>", unsafe_allow_html=True)
                    st.markdown("---")
                    
            except Exception as e:
                st.error(f"‚ùå Error en el an√°lisis de conversaciones: {str(e)}")

# ==================== MEN√ö LATERAL CON NUEVA OPCI√ìN ====================
def mostrar_menu_lateral():
    with st.sidebar:
        st.markdown("### üéØ Modo de An√°lisis")
        
        # Radio button para seleccionar el modo
        modo_analisis = st.radio(
            "Selecciona el tipo de an√°lisis:",
            ["An√°lisis General", "An√°lisis de Conversaciones por Feedback"],
            index=0
        )
        
        return modo_analisis

# ==================== APLICACI√ìN PRINCIPAL MODIFICADA ====================
def main():
    aplicar_estilos()

    # Encabezado din√°mico sin mostrar usuario
    st.markdown(f"""
    <div class="encabezado-principal">
        <h1 style="margin: 0; font-size: 2.5rem;">üìä RAN AVAD Analytics Dashboard</h1>
        <p style="margin: 0.5rem 0 0 0; opacity: 0.9; font-size: 1.2rem;">
            M√©tricas completas - WebApp
        </p>
        <p style="margin: 0.3rem 0 0 0; font-size: 0.9rem; opacity: 0.8;">
            üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Conexi√≥n BD
    usuario, contrase√±a, servidor, base_datos, conectar = mostrar_conexion()

    if conectar:
        with st.spinner("üîÑ Conectando y cargando datos completos..."):
            try:
                tiempo_inicio = datetime.now()
                datos_completos = cargar_datos(usuario, contrase√±a, servidor, base_datos)
                tiempo_carga = (datetime.now() - tiempo_inicio).total_seconds()

                st.session_state.datos = datos_completos
                st.session_state.config_bd = {"user": usuario, "password": contrase√±a, "host": servidor, "database": base_datos}
                st.session_state.bd_conectada = True

                st.markdown(f'<div class="alerta-exito">‚úÖ <strong>Conexi√≥n exitosa!</strong> Cargados {len(datos_completos):,} registros en {tiempo_carga:.2f}s</div>', unsafe_allow_html=True)

            except Exception as e:
                st.markdown(f'<div class="alerta-advertencia">‚ùå <strong>Error:</strong> {str(e)}</div>', unsafe_allow_html=True)
                st.session_state.bd_conectada = False

    # NUEVO MEN√ö LATERAL
    modo_analisis = mostrar_menu_lateral()

    # L√≥gica seg√∫n el modo seleccionado
    if st.session_state.datos is not None:
        if modo_analisis == "An√°lisis General":
            filtros, ejecutar = mostrar_filtros(st.session_state.datos)
            if ejecutar and filtros:
                with st.spinner("üìä Procesando an√°lisis..."):
                    try:
                        tiempo_inicio = datetime.now()
                        resultados = ejecutar_analisis_completo(st.session_state.config_bd, filtros)
                        tiempo_proceso = (datetime.now() - tiempo_inicio).total_seconds()

                        st.session_state.resultados = resultados
                        st.session_state.configuracion = {
                            'mostrar_columnas': filtros.get('mostrar_columnas', []),
                            'mostrar_sin_feedback': filtros.get('mostrar_sin_feedback', True),
                            'solo_completos': filtros.get('solo_completos', False)
                        }

                        st.markdown(f'<div class="alerta-exito">üéâ <strong>¬°Completado!</strong> {len(resultados):,} registros en {tiempo_proceso:.2f}s</div>', unsafe_allow_html=True)

                    except Exception as e:
                        st.markdown(f'<div class="alerta-advertencia">‚ùå <strong>Error:</strong> {str(e)}</div>', unsafe_allow_html=True)

                if st.session_state.resultados is not None:
                    mostrar_resultados_cliente(st.session_state.resultados, st.session_state.configuracion)
        
        else:  # "An√°lisis de Conversaciones por Feedback"
            mostrar_analisis_conversaciones_feedback()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        st.error(f"‚ùå **Error cr√≠tico:** {str(e)}")
        st.markdown("**üîß Soluci√≥n:** Recarga la p√°gina (F5)")
        if st.button("üÜò Reiniciar"):
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.cache_data.clear()
            st.rerun()










primport streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import asyncio
import logging
from datetime import datetime, timedelta
from batch.utilities.chat_history.postgresdbservice import PostgresConversationClient

# ==================== CONFIGURACI√ìN  ====================
logging.basicConfig(level=logging.ERROR)
logger = logging.getLogger(__name__)

st.set_page_config(
    page_title="RAN AVAD Analytics Dashboard",
    page_icon="üí¨",
    layout="wide",
    initial_sidebar_state="expanded"
)

plt.rcParams.update({'font.size': 11, 'figure.facecolor': 'white', 'axes.facecolor': '#fafafa', 'grid.alpha': 0.3})

COLORES = {
    'primario': '#1f77b4', 'exito': '#2ca02c', 'peligro': '#d62728',
    'advertencia': '#ff7f0e', 'info': '#17becf', 'secundario': '#7f7f7f'
}

# ==================== FUNCIONES CORE ====================
@st.cache_data(ttl=600, show_spinner=False)
def normalizar_fechas(serie_dt):
    if serie_dt.empty:
        return serie_dt
    return pd.to_datetime(serie_dt, errors='coerce', utc=True)

def ejecutar_async(corrutina):
    try:
        return asyncio.get_event_loop().run_until_complete(corrutina)
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return loop.run_until_complete(corrutina)

# ==================== ESTILOS ====================
def aplicar_estilos():
    st.markdown("""
    <style>
    .encabezado-principal {background:linear-gradient(90deg,#667eea,#764ba2);padding:2rem;border-radius:10px;color:white;text-align:center;margin-bottom:1.5rem;box-shadow:0 4px 12px rgba(0,0,0,0.15);animation:fadeIn 0.5s ease-in;}
    @keyframes fadeIn {from{opacity:0;transform:translateY(-20px);}to{opacity:1;transform:translateY(0);}}
    .tarjeta-metrica {background:white;padding:1.2rem;border-radius:8px;border-left:4px solid #1f77b4;margin:0.5rem 0;box-shadow:0 3px 10px rgba(0,0,0,0.1);transition:all 0.3s ease;}
    .tarjeta-metrica:hover {transform:translateY(-3px);box-shadow:0 6px 20px rgba(0,0,0,0.15);}
    .numero-metrica {font-size:2rem;font-weight:bold;margin:0;color:#333;animation:countUp 0.8s ease-out;}
    @keyframes countUp {from{opacity:0;transform:scale(0.5);}to{opacity:1;transform:scale(1);}}
    .etiqueta-metrica {color:#666;font-size:0.9rem;margin:0.3rem 0 0 0;}
    .caja-filtros {background:linear-gradient(145deg,#f8f9fa,#e9ecef);padding:1.5rem;border-radius:8px;margin:1rem 0;border:1px solid #e9ecef;transition:all 0.3s ease;}
    .caja-filtros:hover {transform:translateY(-1px);box-shadow:0 4px 15px rgba(0,0,0,0.1);}
    .alerta-exito {background:linear-gradient(135deg,#d4edda,#c3e6cb);border:1px solid #c3e6cb;color:#155724;padding:1rem;border-radius:6px;margin:1rem 0;animation:slideIn 0.5s ease-out;}
    .alerta-info {background:linear-gradient(135deg,#d1ecf1,#bee5eb);border:1px solid #bee5eb;color:#0c5460;padding:1rem;border-radius:6px;margin:1rem 0;animation:slideIn 0.5s ease-out;}
    .alerta-advertencia {background:linear-gradient(135deg,#fff3cd,#ffeaa7);border:1px solid #ffeaa7;color:#856404;padding:1rem;border-radius:6px;margin:1rem 0;animation:slideIn 0.5s ease-out;}
    @keyframes slideIn {from{opacity:0;transform:translateX(-20px);}to{opacity:1;transform:translateX(0);}}

    .contenedor-conversacion {background:white;border-radius:10px;padding:1.5rem;margin:1rem 0;border-left:5px solid #d62728;box-shadow:0 4px 12px rgba(0,0,0,0.1);transition:all 0.3s ease;animation:fadeInUp 0.5s ease-out;}
    .contenedor-conversacion:hover {transform:translateY(-3px);box-shadow:0 8px 25px rgba(0,0,0,0.15);}
    @keyframes fadeInUp {from{opacity:0;transform:translateY(20px);}to{opacity:1;transform:translateY(0);}}
    .encabezado-conversacion {display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;padding-bottom:1rem;border-bottom:2px solid #f8f9fa;}
    .info-conversacion {flex:1;}
    .etiqueta-conversacion {background:#d62728;color:white;padding:0.5rem 1rem;border-radius:20px;font-weight:bold;font-size:0.9rem;animation:pulse 2s infinite;}
    @keyframes pulse {0%,100%{transform:scale(1);}50%{transform:scale(1.05);}}
    .titulo-conversacion {font-size:1.3rem;font-weight:bold;color:#2c3e50;margin:0 0 0.5rem 0;}
    .meta-conversacion {color:#6c757d;font-size:0.9rem;margin:0.2rem 0;}

    .item-mensaje {background:#f8f9fa;border-radius:8px;padding:1rem;margin:0.8rem 0;border-left:4px solid #6c757d;transition:all 0.3s ease;}
    .item-mensaje:hover {background:#e9ecef;transform:translateX(8px);box-shadow:0 3px 12px rgba(0,0,0,0.1);}
    .mensaje-usuario {border-left-color:#2ca02c !important;background:linear-gradient(135deg,#f0fff4,#e6ffed) !important;}
    .mensaje-asistente {border-left-color:#1f77b4 !important;background:linear-gradient(135deg,#f0f8ff,#e6f3ff) !important;}
    .mensaje-sistema {border-left-color:#ff7f0e !important;background:linear-gradient(135deg,#fff8f0,#ffe6d6) !important;}
    .encabezado-mensaje {display:flex;justify-content:space-between;align-items:center;margin-bottom:0.8rem;font-weight:bold;font-size:0.95rem;}
    .rol-mensaje {display:flex;align-items:center;gap:0.5rem;}
    .tiempo-mensaje {color:#6c757d;font-size:0.8rem;font-weight:normal;}
    .contenido-mensaje {background:rgba(255,255,255,0.8);padding:1rem;border-radius:6px;line-height:1.5;font-size:0.95rem;color:#2c3e50;border:1px solid rgba(0,0,0,0.1);transition:all 0.2s ease;}
    .contenido-mensaje:hover {background:rgba(255,255,255,0.95);}

    .info-tecnica-mensaje {margin-top:1rem;padding:0.8rem;background:rgba(0,0,0,0.03);border-radius:6px;border:1px dashed #dee2e6;transition:all 0.2s ease;}
    .info-tecnica-mensaje:hover {background:rgba(0,0,0,0.05);}
    .campo-tecnico {margin:0.5rem 0;padding:0.3rem 0;border-bottom:1px solid #e9ecef;font-size:0.85rem;transition:all 0.2s ease;}
    .campo-tecnico:hover {background:rgba(0,0,0,0.02);}
    .campo-tecnico:last-child {border-bottom:none;}
    .etiqueta-campo {font-weight:bold;color:#495057;margin-right:0.5rem;}
    .valor-campo {color:#6c757d;font-family:'Courier New',monospace;background:white;padding:0.2rem 0.4rem;border-radius:3px;border:1px solid #e9ecef;}

    .resumen-conversacion {background:linear-gradient(135deg,#e3f2fd,#bbdefb);padding:1rem;border-radius:8px;margin-bottom:1rem;border:1px solid #2196f3;animation:slideIn 0.5s ease-out;}
    .cuadricula-resumen {display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;margin-top:0.5rem;}
    .item-resumen {background:white;padding:0.5rem;border-radius:4px;text-align:center;font-size:0.9rem;transition:all 0.2s ease;}
    .item-resumen:hover {transform:scale(1.02);box-shadow:0 2px 8px rgba(0,0,0,0.1);}

    .contenedor-metricas {background:linear-gradient(135deg,#f8f9fa,#e9ecef);padding:2rem;border-radius:12px;margin:2rem 0;border:2px solid #dee2e6;animation:fadeIn 0.8s ease-out;}
    .titulo-seccion {font-size:1.5rem;font-weight:bold;color:#2c3e50;margin-bottom:1.5rem;text-align:center;animation:slideDown 0.6s ease-out;}
    @keyframes slideDown {from{opacity:0;transform:translateY(-10px);}to{opacity:1;transform:translateY(0);}}
    .grafico-contenedor {background:white;padding:1.5rem;border-radius:8px;margin:1rem 0;box-shadow:0 3px 10px rgba(0,0,0,0.1);transition:all 0.3s ease;}
    .grafico-contenedor:hover {transform:translateY(-2px);box-shadow:0 6px 20px rgba(0,0,0,0.15);}
    .pastilla-estadistica {background:linear-gradient(45deg,#e3f2fd,#bbdefb);padding:0.4rem 0.8rem;border-radius:15px;margin:0.3rem;display:inline-block;font-size:0.85rem;transition:all 0.2s ease;}
    .pastilla-estadistica:hover {transform:scale(1.05);box-shadow:0 2px 8px rgba(0,0,0,0.1);}
    </style>
    """, unsafe_allow_html=True)

def crear_metrica(titulo, valor, icono="üìä", color=COLORES['primario']):
    return f"""
    <div class="tarjeta-metrica" style="border-left-color:{color};">
        <div style="display:flex;justify-content:space-between;align-items:center;">
            <div>
                <div class="numero-metrica" style="color:{color};">{valor}</div>
                <div class="etiqueta-metrica">{titulo}</div>
            </div>
            <div style="font-size:1.8rem;opacity:0.7;transition:all 0.3s ease;">{icono}</div>
        </div>
    </div>
    """

# ==================== INICIALIZACI√ìN ====================
if 'bd_conectada' not in st.session_state:
    st.session_state.bd_conectada = False
if 'datos' not in st.session_state:
    st.session_state.datos = None
if 'resultados' not in st.session_state:
    st.session_state.resultados = None

# ==================== CONFIGURACI√ìN BD ====================
def mostrar_conexion():
    with st.sidebar:
        st.markdown("### üîó Conexi√≥n a Base de Datos")
        usuario = st.text_input("Usuario", "usravad")
        contrase√±a = st.text_input("Contrase√±a", "P@w0Rd1.2@25", type="password")
        servidor = st.text_input("Servidor", "teepq02s-euwepc-teradpgsql.postgres.database.azure.com")
        base_datos = st.text_input("Base de Datos", "avad_pre")
        conectar = st.button("üöÄ Conectar", type="primary", use_container_width=True)
        if st.session_state.bd_conectada:
            st.success("‚úÖ Conectado")
    return usuario, contrase√±a, servidor, base_datos, conectar

@st.cache_data(ttl=900, show_spinner=False)
def cargar_datos(_usuario, _contrase√±a, _servidor, _base_datos):
    async def obtener():
        client = PostgresConversationClient(user=_usuario, password=_contrase√±a, host=_servidor, database=_base_datos)
        await client.connect()
        consulta = """
        SELECT m.*, c.title AS conversation_title, c.type AS conversation_type
        FROM messages m
        LEFT JOIN conversations c ON m.conversation_id = c.conversation_id
        ORDER BY m."createdAt" DESC
        """
        resultados = await client.conn.fetch(consulta)
        await client.close()
        df = pd.DataFrame([dict(fila) for fila in resultados])
        if not df.empty and "createdAt" in df.columns:
            df["createdAt"] = normalizar_fechas(df["createdAt"])
        return df
    return ejecutar_async(obtener())

# ==================== SISTEMA DE FILTROS ====================
def mostrar_filtros(df):
    st.markdown("## üéõÔ∏è Panel de Filtros")
    if df.empty:
        st.warning("‚ö†Ô∏è No hay datos disponibles")
        return None, False

    st.markdown(f'<div class="alerta-info">üìä <strong>Datos cargados:</strong> {len(df):,} registros totales disponibles</div>', unsafe_allow_html=True)

    # Filtro temporal
    st.markdown('<div class="caja-filtros">', unsafe_allow_html=True)
    st.markdown("### üìÖ Per√≠odo de An√°lisis")
    try:
        fechas = pd.to_datetime(df["createdAt"], errors='coerce').dropna()
        fecha_min = fechas.min().date() if not fechas.empty else datetime.now().date() - timedelta(days=30)
        fecha_max = fechas.max().date() if not fechas.empty else datetime.now().date()
    except:
        fecha_min = datetime.now().date() - timedelta(days=30)
        fecha_max = datetime.now().date()

    col1, col2 = st.columns(2)
    with col1:
        fecha_inicio = st.date_input("Fecha de Inicio", fecha_min, min_value=fecha_min, max_value=fecha_max)
    with col2:
        fecha_fin = st.date_input("Fecha de Fin", fecha_max, min_value=fecha_min, max_value=fecha_max)
    st.markdown('</div>', unsafe_allow_html=True)

    # Aplicar filtro temporal
    try:
        inicio_dt = pd.Timestamp(fecha_inicio, tz='UTC')
        fin_dt = pd.Timestamp(fecha_fin, tz='UTC') + pd.Timedelta(hours=23, minutes=59, seconds=59)
        df_filtrado = df[(df["createdAt"] >= inicio_dt) & (df["createdAt"] <= fin_dt)]
    except:
        df_filtrado = df

    if df_filtrado.empty:
        st.warning("‚ö†Ô∏è Sin datos en el per√≠odo seleccionado")
        return None, False

    # M√©tricas del per√≠odo
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.markdown(crear_metrica("Total Mensajes", f"{len(df_filtrado):,}", "üí¨"), unsafe_allow_html=True)
    with col2:
        usuarios = df_filtrado["user_id"].nunique() if "user_id" in df_filtrado.columns else 0
        st.markdown(crear_metrica("Usuarios √önicos", f"{usuarios:,}", "üë•", COLORES['exito']), unsafe_allow_html=True)
    with col3:
        conversaciones = df_filtrado["conversation_id"].nunique() if "conversation_id" in df_filtrado.columns else 0
        st.markdown(crear_metrica("Conversaciones", f"{conversaciones:,}", "üó£Ô∏è", COLORES['advertencia']), unsafe_allow_html=True)
    with col4:
        if "feedback" in df_filtrado.columns:
            con_feedback = df_filtrado["feedback"].notna().sum()
            porc_feedback = (con_feedback / len(df_filtrado) * 100) if len(df_filtrado) > 0 else 0
            color = COLORES['exito'] if porc_feedback >= 70 else COLORES['advertencia'] if porc_feedback >= 40 else COLORES['peligro']
            st.markdown(crear_metrica("Con Feedback", f"{porc_feedback:.1f}%", "üìù", color), unsafe_allow_html=True)
        else:
            st.markdown(crear_metrica("Con Feedback", "N/A", "üìù", COLORES['secundario']), unsafe_allow_html=True)

    # Filtros adicionales
    filtros = {'fecha_inicio': fecha_inicio, 'fecha_fin': fecha_fin}
    with st.expander("üîß Filtros Avanzados", expanded=False):
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("**üë• Filtros de Usuario y Rol**")
            if "user_id" in df_filtrado.columns:
                filtros['usuarios'] = st.multiselect("Seleccionar Usuarios", sorted(df_filtrado["user_id"].dropna().unique()))
            if "role" in df_filtrado.columns:
                filtros['roles'] = st.multiselect("Seleccionar Roles", sorted(df_filtrado["role"].dropna().unique()))
        with col2:
            st.markdown("**üó£Ô∏è Filtros de Interacci√≥n**")
            if "feedback" in df_filtrado.columns:
                opciones_feedback = list(df_filtrado["feedback"].dropna().unique()) + ["Sin feedback"]
                filtros['feedback'] = st.multiselect("Tipo de Feedback", opciones_feedback)
            if "type" in df_filtrado.columns:
                filtros['tipos'] = st.multiselect("Tipos de Mensaje", sorted(df_filtrado["type"].dropna().unique()))

    # Configuraci√≥n
    st.markdown('<div class="caja-filtros">', unsafe_allow_html=True)
    st.markdown("### ‚öôÔ∏è Configuraci√≥n del An√°lisis")
    col1, col2 = st.columns(2)
    with col1:
        todas_columnas = ["id", "createdAt", "updatedAt", "user_id", "conversation_id", "role", "type",
                         "content", "feedback", "feedback_content", "expected_response",
                         "expected_documents", "function_call", "question", "llm_filters",
                         "source_documents", "conversation_title", "conversation_type"]
        filtros['mostrar_columnas'] = st.multiselect("Columnas a Mostrar", todas_columnas,
                                                    default=["createdAt", "user_id", "role", "feedback", "content"])
    with col2:
        filtros['mostrar_sin_feedback'] = st.checkbox("Incluir An√°lisis Sin Feedback", value=True)
        filtros['solo_completos'] = st.checkbox("Solo Registros Completos")
    st.markdown('</div>', unsafe_allow_html=True)

    ejecutar = st.button("üöÄ **Ejecutar An√°lisis Completo**", type="primary", use_container_width=True)
    return filtros, ejecutar

# ==================== CONSULTA PRINCIPAL ====================
@st.cache_data(ttl=300, show_spinner=False)
def ejecutar_analisis_completo(_config_bd, filtros):
    async def consulta():
        client = PostgresConversationClient(**_config_bd)
        await client.connect()
        condiciones, parametros = [], []

        if filtros.get('fecha_inicio') and filtros.get('fecha_fin'):
            condiciones.append(f'm."createdAt" BETWEEN ${len(parametros)+1} AND ${len(parametros)+2}')
            parametros.extend([f"{filtros['fecha_inicio']} 00:00:00+00:00", f"{filtros['fecha_fin']} 23:59:59+00:00"])

        mapeo_filtros = {'usuarios': 'm.user_id', 'roles': 'm.role', 'tipos': 'm.type'}
        for clave, campo in mapeo_filtros.items():
            if filtros.get(clave):
                marcadores = ', '.join([f'${len(parametros)+i+1}' for i in range(len(filtros[clave]))])
                condiciones.append(f'{campo} IN ({marcadores})')
                parametros.extend(filtros[clave])

        if filtros.get('feedback'):
            valores_fb = filtros['feedback']
            if 'Sin feedback' in valores_fb:
                valores_limpios = [v for v in valores_fb if v != 'Sin feedback']
                if valores_limpios:
                    marcadores = ', '.join([f'${len(parametros)+i+1}' for i in range(len(valores_limpios))])
                    condiciones.append(f'(m.feedback IN ({marcadores}) OR m.feedback IS NULL)')
                    parametros.extend(valores_limpios)
                else:
                    condiciones.append('m.feedback IS NULL')
            else:
                marcadores = ', '.join([f'${len(parametros)+i+1}' for i in range(len(valores_fb))])
                condiciones.append(f'm.feedback IN ({marcadores})')
                parametros.extend(valores_fb)

        clausula_where = f"WHERE {' AND '.join(condiciones)}" if condiciones else ""
        consulta = f"""
        SELECT m.*, c.title AS conversation_title, c.type AS conversation_type
        FROM messages m
        LEFT JOIN conversations c ON m.conversation_id = c.conversation_id
        {clausula_where}
        ORDER BY m."createdAt" DESC
        """

        resultados = await client.conn.fetch(consulta, *parametros)
        await client.close()
        df = pd.DataFrame([dict(fila) for fila in resultados])
        if not df.empty and "createdAt" in df.columns:
            df["createdAt"] = normalizar_fechas(df["createdAt"])
        return df
    return ejecutar_async(consulta())

# ==================== M√âTRICAS ====================
def crear_metricas_especificas(df):
    """SOLO 2 m√©tricas: Tipos de Feedback y Comparaci√≥n de Usuarios"""
    if df.empty:
        return

    st.markdown("## üìä M√©tricas Espec√≠ficas de An√°lisis")
    st.markdown('<div class="contenedor-metricas">', unsafe_allow_html=True)

    col1, col2 = st.columns(2)

    # M√âTRICA 1: Tipos de Feedback
    with col1:
        st.markdown('<div class="grafico-contenedor">', unsafe_allow_html=True)
        st.markdown('<div class="titulo-seccion">üìä Distribuci√≥n de Tipos de Feedback</div>', unsafe_allow_html=True)

        if "feedback" in df.columns:
            feedback_data = df["feedback"].fillna("Sin feedback").value_counts()
            fig_fb, ax_fb = plt.subplots(figsize=(10, 6))

            colores_feedback = []
            for tipo in feedback_data.index:
                if tipo == 'positive':
                    colores_feedback.append(COLORES['exito'])
                elif tipo == 'negative':
                    colores_feedback.append(COLORES['peligro'])
                else:
                    colores_feedback.append(COLORES['advertencia'])

            barras = ax_fb.bar(feedback_data.index, feedback_data.values,
                              color=colores_feedback, alpha=0.8, edgecolor='white', linewidth=2)

            ax_fb.set_title('Distribuci√≥n de Tipos de Feedback', fontsize=14, fontweight='bold', pad=20)
            ax_fb.set_ylabel('Cantidad de Mensajes', fontsize=12)
            ax_fb.set_xlabel('Tipo de Feedback', fontsize=12)
            ax_fb.grid(axis='y', alpha=0.3)

            for barra in barras:
                altura = barra.get_height()
                ax_fb.text(barra.get_x() + barra.get_width()/2., altura + feedback_data.max()*0.01,
                          f'{int(altura)}\n({altura/len(df)*100:.1f}%)',
                          ha='center', va='bottom', fontweight='bold', fontsize=10)

            ax_fb.spines['top'].set_visible(False)
            ax_fb.spines['right'].set_visible(False)
            plt.tight_layout()
            st.pyplot(fig_fb)

            st.markdown("**üìà Estad√≠sticas de Feedback:**")
            for tipo, cantidad in feedback_data.items():
                porcentaje = (cantidad / len(df)) * 100
                color_stat = COLORES['exito'] if tipo == 'positive' else COLORES['peligro'] if tipo == 'negative' else COLORES['advertencia']
                st.markdown(f'<div class="pastilla-estadistica" style="background: linear-gradient(45deg, {color_stat}, {color_stat}aa); color: white; font-weight: bold;">**{tipo.title()}**: {cantidad:,} ({porcentaje:.1f}%)</div>',
                           unsafe_allow_html=True)

        st.markdown('</div>', unsafe_allow_html=True)

    # M√âTRICA 2: Usuarios Con vs Sin Feedback
    with col2:
        st.markdown('<div class="grafico-contenedor">', unsafe_allow_html=True)
        st.markdown('<div class="titulo-seccion">üë• Comparaci√≥n: Usuarios Con vs Sin Feedback</div>', unsafe_allow_html=True)

        if "feedback" in df.columns and "user_id" in df.columns:
            stats_usuarios = df.groupby("user_id").agg({
                "feedback": [lambda x: (x.isna()).sum(), lambda x: (x.notna()).sum()]
            }).round(2)

            stats_usuarios.columns = ["sin_feedback", "con_feedback"]
            stats_usuarios["total_mensajes"] = stats_usuarios["sin_feedback"] + stats_usuarios["con_feedback"]
            stats_usuarios["porcentaje_sin_feedback"] = (stats_usuarios["sin_feedback"] / stats_usuarios["total_mensajes"]) * 100

            usuarios_problematicos = stats_usuarios[stats_usuarios["sin_feedback"] > stats_usuarios["con_feedback"]]
            usuarios_problematicos = usuarios_problematicos.sort_values("porcentaje_sin_feedback", ascending=False).head(10)

            if not usuarios_problematicos.empty:
                fig_users, ax_users = plt.subplots(figsize=(10, 8))
                y_pos = range(len(usuarios_problematicos))

                barras_sin = ax_users.barh([y - 0.2 for y in y_pos], usuarios_problematicos["sin_feedback"].values,
                                          height=0.4, label='Sin Feedback', color=COLORES['peligro'], alpha=0.8)
                barras_con = ax_users.barh([y + 0.2 for y in y_pos], usuarios_problematicos["con_feedback"].values,
                                          height=0.4, label='Con Feedback', color=COLORES['exito'], alpha=0.8)

                ax_users.set_yticks(y_pos)
                ax_users.set_yticklabels([f"Usuario {uid}" for uid in usuarios_problematicos.index])
                ax_users.set_xlabel('Cantidad de Mensajes', fontsize=12)
                ax_users.set_title('Top 10 Usuarios con M√°s Mensajes Sin Feedback', fontsize=14, fontweight='bold', pad=20)
                ax_users.legend(loc='lower right')
                ax_users.grid(axis='x', alpha=0.3)

                for i, (barra_sin, barra_con) in enumerate(zip(barras_sin, barras_con)):
                    width_sin = barra_sin.get_width()
                    if width_sin > 0:
                        ax_users.text(width_sin + usuarios_problematicos["sin_feedback"].max()*0.01,
                                     barra_sin.get_y() + barra_sin.get_height()/2,
                                     f'{int(width_sin)}', va='center', fontweight='bold', color=COLORES['peligro'])

                    width_con = barra_con.get_width()
                    if width_con > 0:
                        ax_users.text(width_con + usuarios_problematicos["con_feedback"].max()*0.01,
                                     barra_con.get_y() + barra_con.get_height()/2,
                                     f'{int(width_con)}', va='center', fontweight='bold', color=COLORES['exito'])

                ax_users.spines['top'].set_visible(False)
                ax_users.spines['right'].set_visible(False)
                plt.tight_layout()
                st.pyplot(fig_users)

                st.markdown("**üö® Usuarios que Requieren Atenci√≥n:**")
                for usuario, datos in usuarios_problematicos.head(5).iterrows():
                    st.markdown(f'<div class="pastilla-estadistica" style="background: linear-gradient(45deg, {COLORES["peligro"]}, {COLORES["peligro"]}aa); color: white; font-weight: bold;">**Usuario {usuario}**: {datos["porcentaje_sin_feedback"]:.1f}% sin feedback ({datos["sin_feedback"]} de {datos["total_mensajes"]})</div>',
                               unsafe_allow_html=True)
            else:
                st.markdown('<div class="alerta-exito">‚úÖ <strong>¬°Excelente!</strong> No hay usuarios con m√°s mensajes sin feedback que con feedback.</div>',
                           unsafe_allow_html=True)

        st.markdown('</div>', unsafe_allow_html=True)

    st.markdown('</div>', unsafe_allow_html=True)

# ==================== AN√ÅLISIS SIN FEEDBACK COMPLETO ====================
def analizar_conversaciones_sin_feedback(df):
    st.markdown("## üîç An√°lisis Completo de Conversaciones Sin Feedback")

    if "feedback" not in df.columns:
        st.info("‚ÑπÔ∏è No hay datos de feedback disponibles")
        return

    sin_feedback = df[df["feedback"].isna()].copy()
    if sin_feedback.empty:
        st.markdown('<div class="alerta-exito">‚úÖ <strong>¬°Excelente!</strong> Todas las conversaciones tienen feedback.</div>', unsafe_allow_html=True)
        return

    total_sin_feedback = len(sin_feedback)
    conversaciones_afectadas = sin_feedback["conversation_id"].nunique() if "conversation_id" in sin_feedback.columns else 0
    usuarios_afectados = sin_feedback["user_id"].nunique() if "user_id" in sin_feedback.columns else 0

    st.markdown(f'<div class="alerta-info">üìã <strong>{total_sin_feedback:,} mensajes sin feedback</strong> en <strong>{conversaciones_afectadas:,} conversaciones</strong> de <strong>{usuarios_afectados:,} usuarios</strong></div>', unsafe_allow_html=True)

    grupos_conversacion = sin_feedback.groupby("conversation_id")
    stats_conversaciones = sin_feedback.groupby("conversation_id").agg({
        "id": "count", "user_id": "first", "conversation_title": "first",
        "createdAt": ["min", "max"], "role": lambda x: list(x.unique()),
        "type": lambda x: list(x.unique())
    }).round(2)

    stats_conversaciones.columns = ["cantidad_mensajes", "id_usuario", "titulo", "tiempo_inicio", "tiempo_fin", "roles", "tipos"]
    stats_conversaciones = stats_conversaciones.sort_values("cantidad_mensajes", ascending=False)

    total_conversaciones = len(stats_conversaciones)
    conversaciones_por_pagina = st.selectbox("Conversaciones por p√°gina:", [5, 10, 15, 20, 30], index=2)

    if total_conversaciones > conversaciones_por_pagina:
        total_paginas = (total_conversaciones + conversaciones_por_pagina - 1) // conversaciones_por_pagina
        pagina_actual = st.selectbox(f"P√°gina (Total: {total_paginas}):", range(1, total_paginas + 1))
        indice_inicio = (pagina_actual - 1) * conversaciones_por_pagina
        indice_fin = indice_inicio + conversaciones_por_pagina
        stats_pagina = stats_conversaciones.iloc[indice_inicio:indice_fin]
        st.markdown(f'<div class="alerta-info">üìÑ Mostrando conversaciones {indice_inicio + 1} a {min(indice_fin, total_conversaciones)} de {total_conversaciones}</div>', unsafe_allow_html=True)
    else:
        stats_pagina = stats_conversaciones

    for posicion, (id_conversacion, estadisticas) in enumerate(stats_pagina.iterrows(), 1):
        datos_conversacion = grupos_conversacion.get_group(id_conversacion)

        if estadisticas['cantidad_mensajes'] > 15:
            nivel_prioridad = "üî¥ Cr√≠tica"
            color_prioridad = COLORES['peligro']
        elif estadisticas['cantidad_mensajes'] > 8:
            nivel_prioridad = "üü° Alta"
            color_prioridad = COLORES['advertencia']
        else:
            nivel_prioridad = "üü¢ Media"
            color_prioridad = COLORES['exito']

        st.markdown(f"""
        <div class="contenedor-conversacion">
            <div class="encabezado-conversacion">
                <div class="info-conversacion">
                    <div class="titulo-conversacion">üó£Ô∏è Conversaci√≥n {id_conversacion}</div>
                    <div class="meta-conversacion">üìã <strong>T√≠tulo:</strong> {estadisticas['titulo'] if pd.notna(estadisticas['titulo']) else 'Sin t√≠tulo'}</div>
                    <div class="meta-conversacion">üë§ <strong>Usuario:</strong> {estadisticas['id_usuario']} | üé≠ <strong>Roles:</strong> {', '.join(estadisticas['roles'])}</div>
                    <div class="meta-conversacion">üìÖ <strong>Per√≠odo:</strong> {pd.to_datetime(estadisticas['tiempo_inicio']).strftime('%Y-%m-%d %H:%M')} ‚Üí {pd.to_datetime(estadisticas['tiempo_fin']).strftime('%Y-%m-%d %H:%M')}</div>
                    <div class="meta-conversacion">‚ö†Ô∏è <strong>Prioridad:</strong> <span style="color: {color_prioridad}; font-weight: bold;">{nivel_prioridad}</span></div>
                </div>
                <div class="etiqueta-conversacion">{estadisticas['cantidad_mensajes']} mensajes</div>
            </div>
        """, unsafe_allow_html=True)

        duracion = pd.to_datetime(estadisticas['tiempo_fin']) - pd.to_datetime(estadisticas['tiempo_inicio'])
        resumen_tipos = dict(datos_conversacion['type'].value_counts())
        promedio_diario = estadisticas['cantidad_mensajes'] / max(1, duracion.days) if duracion.days > 0 else estadisticas['cantidad_mensajes']

        st.markdown(f"""
        <div class="resumen-conversacion">
            <strong>üìä Resumen de la Conversaci√≥n</strong>
            <div class="cuadricula-resumen">
                <div class="item-resumen"><strong>‚è±Ô∏è Duraci√≥n:</strong><br>{duracion}</div>
                <div class="item-resumen"><strong>üìù Tipos √∫nicos:</strong><br>{len(resumen_tipos)}</div>
                <div class="item-resumen"><strong>üé≠ Roles:</strong><br>{len(estadisticas['roles'])}</div>
                <div class="item-resumen"><strong>üìä Promedio/d√≠a:</strong><br>{promedio_diario:.1f}</div>
            </div>
        </div>
        """, unsafe_allow_html=True)

        with st.expander(f"üëÅÔ∏è Ver los {estadisticas['cantidad_mensajes']} mensajes de la conversaci√≥n {id_conversacion}", expanded=False):
            mensajes_ordenados = datos_conversacion.sort_values("createdAt")

            for indice_mensaje, (_, mensaje) in enumerate(mensajes_ordenados.iterrows(), 1):
                rol = mensaje.get("role", "N/A").lower()
                contenido = mensaje.get("content", "[Sin contenido]").strip()
                timestamp = pd.to_datetime(mensaje.get("createdAt", "")).strftime("%Y-%m-%d %H:%M:%S")
                tipo_mensaje = mensaje.get("type", "general")
                id_usuario = mensaje.get("user_id", "desconocido")

                if rol == "user":
                    clase_css = "mensaje-usuario"
                    icono = "üë§"
                    nombre_rol = "Usuario"
                elif rol == "assistant":
                    clase_css = "mensaje-asistente"
                    icono = "ü§ñ"
                    nombre_rol = "Asistente"
                else:
                    clase_css = "mensaje-sistema"
                    icono = "‚öôÔ∏è"
                    nombre_rol = "Sistema"

                st.markdown(f"""
                <div class="item-mensaje {clase_css}">
                    <div class="encabezado-mensaje">
                        <div class="rol-mensaje">
                            <span>{icono}</span>
                            <span><strong>Mensaje #{indice_mensaje} - {nombre_rol}</strong></span>
                            <span style="font-size:0.8rem;color:#6c757d;">({tipo_mensaje})</span>
                        </div>
                        <div class="tiempo-mensaje">üïê {timestamp} | üë§ {id_usuario}</div>
                    </div>
                    <div class="contenido-mensaje">
                        <strong>üí¨ Contenido:</strong><br>
                        {contenido[:1000]}{'...' if len(contenido) > 1000 else ''}
                    </div>
                """, unsafe_allow_html=True)

                campos_tecnicos = {
                    "question": "‚ùì Pregunta", "expected_response": "üìå Respuesta Esperada",
                    "expected_documents": "üìé Documentos Esperados", "function_call": "‚öôÔ∏è Funci√≥n",
                    "llm_filters": "üîç Filtros LLM", "source_documents": "üìö Documentos",
                    "feedback_content": "üí≠ Contenido Feedback"
                }

                tiene_info_tecnica = False
                html_tecnico = '<div class="info-tecnica-mensaje"><strong>üîß Informaci√≥n T√©cnica:</strong><br>'

                for campo, etiqueta in campos_tecnicos.items():
                    valor_campo = mensaje.get(campo)
                    if valor_campo and str(valor_campo).strip() not in ['', 'nan', 'None', 'null']:
                        tiene_info_tecnica = True
                        valor_mostrar = str(valor_campo)[:400] + ('...' if len(str(valor_campo)) > 400 else '')
                        html_tecnico += f'<div class="campo-tecnico"><span class="etiqueta-campo">{etiqueta}:</span><span class="valor-campo">{valor_mostrar}</span></div>'

                html_tecnico += '</div>'
                if tiene_info_tecnica:
                    st.markdown(html_tecnico, unsafe_allow_html=True)

                st.markdown("</div>", unsafe_allow_html=True)

        st.markdown("</div>", unsafe_allow_html=True)
        st.markdown("---")

# ==================== PRESENTACI√ìN DE RESULTADOS ====================
def mostrar_resultados_cliente(df, configuracion):
    st.markdown("## üìã Resultados del An√°lisis")

    if df.empty:
        st.warning("‚ö†Ô∏è No se encontraron datos con los filtros aplicados")
        return

    if configuracion.get('solo_completos', False):
        longitud_original = len(df)
        campos_requeridos = ["feedback", "content", "user_id", "conversation_id"]
        df = df.dropna(subset=campos_requeridos)
        excluidos = longitud_original - len(df)
        if excluidos > 0:
            st.info(f"‚ÑπÔ∏è Se excluyeron {excluidos:,} registros incompletos")

    # SOLO las 2 m√©tricas espec√≠ficas solicitadas
    crear_metricas_especificas(df)

    # Tabla de datos
    st.markdown("### üìä Tabla de Datos Analizados")
    columnas_mostrar = configuracion.get('mostrar_columnas', [])
    if columnas_mostrar:
        columnas_existentes = [col for col in columnas_mostrar if col in df.columns]
        df_mostrar = df[columnas_existentes] if columnas_existentes else df
    else:
        df_mostrar = df

    df_visualizar = df_mostrar.copy()
    for columna_fecha in ["createdAt", "updatedAt"]:
        if columna_fecha in df_visualizar.columns:
            df_visualizar[columna_fecha] = pd.to_datetime(df_visualizar[columna_fecha], errors='coerce').dt.strftime('%Y-%m-%d %H:%M')

    st.markdown(f'<div class="alerta-info">üìä Mostrando {len(df_visualizar):,} registros con {len(df_visualizar.columns)} columnas</div>', unsafe_allow_html=True)
    st.dataframe(df_visualizar, use_container_width=True, height=500)

    # Exportaci√≥n
    try:
        df_exportar = df.copy()
        for columna in df_exportar.columns:
            if df_exportar[columna].dtype == 'datetime64[ns, UTC]':
                df_exportar[columna] = df_exportar[columna].dt.strftime('%Y-%m-%d %H:%M:%S')
        for columna in df_exportar.select_dtypes(include='object'):
            df_exportar[columna] = df_exportar[columna].astype(str).str.strip()

        datos_csv = df_exportar.to_csv(index=False, encoding='utf-8-sig', sep=';')

        col1, col2 = st.columns(2)
        with col1:
            st.download_button("üì• Exportar An√°lisis Completo (CSV)", datos_csv,
                             f"analisis_completo_{datetime.now().strftime('%Y%m%d_%H%M')}.csv",
                             "text/csv", type="primary", use_container_width=True)
        with col2:
            if columnas_mostrar:
                datos_csv_vista = df_visualizar.to_csv(index=False, encoding='utf-8-sig', sep=';')
                st.download_button("üì• Exportar Vista Personalizada (CSV)", datos_csv_vista,
                                 f"vista_personalizada_{datetime.now().strftime('%Y%m%d_%H%M')}.csv",
                                 "text/csv", use_container_width=True)
    except Exception as e:
        st.error(f"Error en exportaci√≥n: {e}")

    # An√°lisis sin feedback
    if configuracion.get('mostrar_sin_feedback', True):
        analizar_conversaciones_sin_feedback(df)

# ==================== APLICACI√ìN PRINCIPAL ====================
def main():
    aplicar_estilos()

    # Encabezado din√°mico sin mostrar usuario
    st.markdown(f"""
    <div class="encabezado-principal">
        <h1 style="margin: 0; font-size: 2.5rem;">üìä RAN AVAD Analytics Dashboard</h1>
        <p style="margin: 0.5rem 0 0 0; opacity: 0.9; font-size: 1.2rem;">
            M√©tricas completas - WebApp
        </p>
        <p style="margin: 0.3rem 0 0 0; font-size: 0.9rem; opacity: 0.8;">
            üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Conexi√≥n BD
    usuario, contrase√±a, servidor, base_datos, conectar = mostrar_conexion()

    if conectar:
        with st.spinner("üîÑ Conectando y cargando datos completos..."):
            try:
                tiempo_inicio = datetime.now()
                datos_completos = cargar_datos(usuario, contrase√±a, servidor, base_datos)
                tiempo_carga = (datetime.now() - tiempo_inicio).total_seconds()

                st.session_state.datos = datos_completos
                st.session_state.config_bd = {"user": usuario, "password": contrase√±a, "host": servidor, "database": base_datos}
                st.session_state.bd_conectada = True

                st.markdown(f'<div class="alerta-exito">‚úÖ <strong>Conexi√≥n exitosa!</strong> Cargados {len(datos_completos):,} registros en {tiempo_carga:.2f}s</div>', unsafe_allow_html=True)

                if not datos_completos.empty:
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.info(f"üìä **Total:** {len(datos_completos):,}")
                    with col2:
                        usuarios_totales = datos_completos["user_id"].nunique() if "user_id" in datos_completos.columns else 0
                        st.info(f"üë• **Usuarios:** {usuarios_totales:,}")
                    with col3:
                        conversaciones_totales = datos_completos["conversation_id"].nunique() if "conversation_id" in datos_completos.columns else 0
                        st.info(f"üó£Ô∏è **Conversaciones:** {conversaciones_totales:,}")

            except Exception as e:
                st.markdown(f'<div class="alerta-advertencia">‚ùå <strong>Error:</strong> {str(e)}</div>', unsafe_allow_html=True)
                st.session_state.bd_conectada = False

    # Filtros y an√°lisis
    if st.session_state.datos is not None:
        filtros, ejecutar = mostrar_filtros(st.session_state.datos)

        if ejecutar and filtros:
            with st.spinner("üìä Procesando an√°lisis..."):
                try:
                    tiempo_inicio = datetime.now()
                    resultados = ejecutar_analisis_completo(st.session_state.config_bd, filtros)
                    tiempo_proceso = (datetime.now() - tiempo_inicio).total_seconds()

                    st.session_state.resultados = resultados
                    st.session_state.configuracion = {
                        'mostrar_columnas': filtros.get('mostrar_columnas', []),
                        'mostrar_sin_feedback': filtros.get('mostrar_sin_feedback', True),
                        'solo_completos': filtros.get('solo_completos', False)
                    }

                    st.markdown(f'<div class="alerta-exito">üéâ <strong>¬°Completado!</strong> {len(resultados):,} registros en {tiempo_proceso:.2f}s</div>', unsafe_allow_html=True)

                except Exception as e:
                    st.markdown(f'<div class="alerta-advertencia">‚ùå <strong>Error:</strong> {str(e)}</div>', unsafe_allow_html=True)

    # Resultados
    if st.session_state.resultados is not None:
        mostrar_resultados_cliente(st.session_state.resultados, st.session_state.configuracion)

    # Panel estado sin mostrar usuario
    with st.sidebar:
        st.markdown("---")
        st.markdown("### üìä Estado del Sistema")
        items_estado = [
            ("üïê Hora", datetime.now().strftime('%H:%M:%S')),
            ("üîó BD", "‚úÖ Conectada" if st.session_state.bd_conectada else "‚ùå Desconectada"),
            ("üìä Datos", f"‚úÖ {len(st.session_state.datos):,}" if st.session_state.datos is not None else "‚ùå Sin datos"),
            ("üìã Resultados", f"‚úÖ {len(st.session_state.resultados):,}" if st.session_state.resultados is not None else "‚ùå Sin an√°lisis")
        ]

        for etiqueta, valor in items_estado:
            st.markdown(f"**{etiqueta}:** {valor}")

        if st.button("üîÑ Actualizar Cache"):
            st.cache_data.clear()
            st.success("‚úÖ Cache actualizada")
            st.rerun()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        st.error(f"‚ùå **Error cr√≠tico:** {str(e)}")
        st.markdown("**üîß Soluci√≥n:** Recarga la p√°gina (F5)")
        if st.button("üÜò Reiniciar"):
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.cache_data.clear()
            st.rerun()
ueba
